{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Falaremos sobre Cont\u00eaineres? \u00b6 Para iniciar essa conversa acho importante ter uma vis\u00e3o geral sobre o conte\u00fado \u00e9 importante que voc\u00ea assista o video do C\u00f3digo Fonte TV que explica sobre cont\u00eaineres. Como cont\u00eaineres funcionam? \u00b6 Temos agora uma base te\u00f3rica para trabalhar, refor\u00e7aremos o conceito de M\u00e1quina Virtual e Cont\u00eaineres: Cont\u00eaineres s\u00e3o medidos em megabyte. Eles cont\u00eam, no m\u00e1ximo, a aplica\u00e7\u00e3o e os arquivos necess\u00e1rios para execut\u00e1-la. Al\u00e9m disso, eles costumam ser usados para empacotar fun\u00e7\u00f5es individuais que realizam tarefas espec\u00edficas, os famosos microsservi\u00e7os. Como s\u00e3o leves e t\u00eam um sistema operacional compartilhado, os cont\u00eaineres s\u00e3o muito f\u00e1ceis de migrar entre v\u00e1rios ambientes. As m\u00e1quinas virtuais(VM) s\u00e3o medidas em gigabyte. Eles costumam ter seu pr\u00f3prio sistema operacional, possibilitando a execu\u00e7\u00e3o simult\u00e2nea de v\u00e1rias fun\u00e7\u00f5es com uso intenso de recursos. Por terem um n\u00famero maior de recursos \u00e0 disposi\u00e7\u00e3o, as m\u00e1quinas virtuais conseguem abstrair, dividir, duplicar e emular por inteiro servidores, sistemas operacionais, desktops, bancos de dados e redes. Temos essa imagem para ilustra melhor esse conceito: Virtualiza\u00e7\u00e3o : O hipervisor \u00e9 um software que separa os recursos das respectivas m\u00e1quinas f\u00edsicas para eles poderem ser particionados e dedicados \u00e0s m\u00e1quinas virtuais. Quando o usu\u00e1rio emite uma instru\u00e7\u00e3o de m\u00e1quina virtual que exige mais recursos do ambiente f\u00edsico, o hipervisor retransmite a solicita\u00e7\u00e3o ao sistema f\u00edsico e armazena as mudan\u00e7as em mem\u00f3ria transit\u00f3ria. As m\u00e1quinas virtuais s\u00e3o similares aos servidores f\u00edsicos e agem como eles, o que pode multiplicar as desvantagens de grandes infraestruturas de sistema operacional e das depend\u00eancias da aplica\u00e7\u00e3o. Na maioria das vezes, essas infraestruturas n\u00e3o s\u00e3o necess\u00e1rias para executar uma aplica\u00e7\u00e3o ou microsservi\u00e7os. Cont\u00eaineres : Os cont\u00eaineres armazenam um microsservi\u00e7o ou aplica\u00e7\u00e3o, al\u00e9m de todos os elementos necess\u00e1rios para execut\u00e1-los. Tudo que eles cont\u00eam \u00e9 mantido em um recurso chamado imagem: um arquivo baseado em c\u00f3digo que inclui todas as bibliotecas e depend\u00eancias. Pense nesses arquivos como uma instala\u00e7\u00e3o da distribui\u00e7\u00e3o Linux, j\u00e1 que a imagem inclui pacotes RPM e arquivos de configura\u00e7\u00e3o. Como os cont\u00eaineres s\u00e3o muito pequenos, geralmente h\u00e1 centenas deles levemente acoplados. J\u00e1 que sabemos a diferen\u00e7a entre VM e Cont\u00eaineres, precisamos entender aonde essa solu\u00e7\u00e3o se encaixa, pois, com as mudan\u00e7as que a tecnologia traz no decorrer da sua hist\u00f3ria, \u00e9 preciso entender as novas pr\u00e1ticas de TI com as tradicionais para chegamos a um ponto-chave dessa pergunta: As novas pr\u00e1ticas de TI (desenvolvimento nativo em nuvem, CI/CD e DevOps) existem gra\u00e7as \u00e0 divis\u00e3o das cargas de trabalho nas menores unidades \u00fateis poss\u00edveis, que geralmente s\u00e3o uma fun\u00e7\u00e3o ou um microsservi\u00e7o. Essas unidades s\u00e3o melhor empacotadas em cont\u00eaineres. Assim, v\u00e1rias equipes podem trabalhar em partes separadas de uma aplica\u00e7\u00e3o ou servi\u00e7o sem interromper, ou p\u00f4r em risco o c\u00f3digo empacotado em outros cont\u00eaineres. Nas arquiteturas de TI tradicionais (monol\u00edticas e legadas), todos os elementos de uma carga de trabalho s\u00e3o mantidos em um arquivo grande que n\u00e3o pode ser dividido. Por isso, ele precisa ser empacotado como uma unidade completa em um ambiente maior, frequentemente uma m\u00e1quina virtual. Era comum criar e executar uma aplica\u00e7\u00e3o inteira dentro de uma m\u00e1quina virtual, mesmo sabendo que ao armazenar todo o c\u00f3digo e depend\u00eancias, ela ficava grande demais, e isso poderia gerar falhas em cascata e downtime durante as atualiza\u00e7\u00f5es. Se aprofundando um pouco mais nos Cont\u00eaineres \u00b6 Se em algum momento voc\u00ea j\u00e1 usou uma VM, imagino que tenha passado pelo processo de baixa uma SO, seja Linux ou Windows e alocando os recursos conforme a capacidade do hardware dispon\u00edvel, ent\u00e3o esse processo dos Cont\u00eaineres pode parecer meio confuso, para isso deixei duas perguntas que precisamos responder antes de cont\u00ednua. Se n\u00e3o \u00e9 uma virtualiza\u00e7\u00e3o como ocorre o isolamento? Como ocorre a divis\u00e3o de recursos? Se n\u00e3o \u00e9 uma virtualiza\u00e7\u00e3o como ocorre o isolamento? \u00b6 Existe uma palavra importante, que resolve essa quest\u00e3o Namespaces , permitindo que os cont\u00eaineres consigam isolamento em determinados n\u00edveis que s\u00e3o: PID : Isola os processos rodando dentro do cont\u00eainer NET : Isola as interfaces de redes IPC : Isola a comunica\u00e7\u00e3o entre processos e memoria MNT : Isola o ponto de montagem UTS : Isola o Kernel, ou seja, simula um novo host(usu\u00e1rio) USER : Isola os arquivos do sistema Dentre esse processo o mais importante, \u00e9 o UTS, o respons\u00e1vel pelo isolamento dos cont\u00eaineres, ao simular um novo host, ele usar o Kernel da m\u00e1quina f\u00edsica para o processamento, por\u00e9m isoladamente. Os namespaces fazem parte do kernel do Linux desde 2002, os namespaces s\u00e3o respons\u00e1veis por gerar o isolamento de grupos de processos em seu n\u00edvel l\u00f3gico. Como ocorre a divis\u00e3o de recursos? \u00b6 O gerenciamento de recursos, tem a palavra Cgroups para resolver essa demanda de gerenciar, seja ela automaticamente ou manualmente. Os cgroups fornecem os recursos: Limites de recursos : voc\u00ea pode configurar um cgroup para limitar quanto de um determinado recurso (mem\u00f3ria ou CPU, por exemplo) um processo pode usar. Prioriza\u00e7\u00e3o : Voc\u00ea pode controlar quanto de um recurso (CPU, disco ou rede) um processo pode usar em compara\u00e7\u00e3o com processos em outro cgroup quando h\u00e1 conten\u00e7\u00e3o de recursos. Contabilidade : os limites de recursos s\u00e3o monitorados e relatados no n\u00edvel do cgroup. Controle : Voc\u00ea pode alterar o status (congelado, interrompido ou reiniciado) de todos os processos em um cgroup com um \u00fanico comando. Os cgroups s\u00e3o um componente-chave dos cont\u00eaineres porque geralmente h\u00e1 v\u00e1rios processos em execu\u00e7\u00e3o em um cont\u00eainer que precisam ser controlados juntos. Agora que entendemos o significado de cont\u00eaineres, temos mais duas palavras importantes para aprender: Kubernetes Swarm Essas duas palavras possuem uma frase em comum: orquestra\u00e7\u00e3o de containers Para que serve a orquestra\u00e7\u00e3o de cont\u00eaineres? \u00b6 Basicamente, a orquestra\u00e7\u00e3o de cont\u00eaineres automatiza a implanta\u00e7\u00e3o, o gerenciamento, a escala e a rede dos cont\u00eaineres. Use a orquestra\u00e7\u00e3o de cont\u00eaineres para automatizar e gerenciar tarefas como: Provisionamento e implanta\u00e7\u00e3o Configura\u00e7\u00e3o e programa\u00e7\u00e3o Aloca\u00e7\u00e3o de recursos Disponibilidade dos containers Escala ou remo\u00e7\u00e3o de containers com base no balanceamento de cargas de trabalho na infraestrutura Balanceamento de carga e roteamento de tr\u00e1fego Monitoramento da integridade do container Configura\u00e7\u00e3o da aplica\u00e7\u00e3o com base no container em que ela ser\u00e1 executada Prote\u00e7\u00e3o das intera\u00e7\u00f5es entre os containers As ferramentas de orquestra\u00e7\u00e3o de cont\u00eaineres fornecem um framework para gerenciar arquiteturas de microsservi\u00e7os e cont\u00eaineres em escala. Muitas delas podem ser usadas no gerenciamento do ciclo de vida dos cont\u00eaineres. Algumas op\u00e7\u00f5es s\u00e3o o Kubernetes, Docker Swarm e Apache Mesos, DC/SO e N\u00f4made. Nesse tema vamos aborda sobre e praticar: Docker Docker Swarm: Cluster do Docker Kubernetes Cluster Plano de controle Kubelet Pod Google Kubernetes Amazon Kubernetes Azure Kubernetes Fontes usadas para elabora\u00e7\u00e3o desse conte\u00fado \u00b6 Red Hat: Cont\u00eaineres vs Vms Red Hat: Orquestra\u00e7\u00e3o de containers etcd: O que s\u00e3o namespaces e cgroups","title":"Inicio"},{"location":"#falaremos-sobre-conteineres","text":"Para iniciar essa conversa acho importante ter uma vis\u00e3o geral sobre o conte\u00fado \u00e9 importante que voc\u00ea assista o video do C\u00f3digo Fonte TV que explica sobre cont\u00eaineres.","title":"Falaremos sobre Cont\u00eaineres?"},{"location":"#como-conteineres-funcionam","text":"Temos agora uma base te\u00f3rica para trabalhar, refor\u00e7aremos o conceito de M\u00e1quina Virtual e Cont\u00eaineres: Cont\u00eaineres s\u00e3o medidos em megabyte. Eles cont\u00eam, no m\u00e1ximo, a aplica\u00e7\u00e3o e os arquivos necess\u00e1rios para execut\u00e1-la. Al\u00e9m disso, eles costumam ser usados para empacotar fun\u00e7\u00f5es individuais que realizam tarefas espec\u00edficas, os famosos microsservi\u00e7os. Como s\u00e3o leves e t\u00eam um sistema operacional compartilhado, os cont\u00eaineres s\u00e3o muito f\u00e1ceis de migrar entre v\u00e1rios ambientes. As m\u00e1quinas virtuais(VM) s\u00e3o medidas em gigabyte. Eles costumam ter seu pr\u00f3prio sistema operacional, possibilitando a execu\u00e7\u00e3o simult\u00e2nea de v\u00e1rias fun\u00e7\u00f5es com uso intenso de recursos. Por terem um n\u00famero maior de recursos \u00e0 disposi\u00e7\u00e3o, as m\u00e1quinas virtuais conseguem abstrair, dividir, duplicar e emular por inteiro servidores, sistemas operacionais, desktops, bancos de dados e redes. Temos essa imagem para ilustra melhor esse conceito: Virtualiza\u00e7\u00e3o : O hipervisor \u00e9 um software que separa os recursos das respectivas m\u00e1quinas f\u00edsicas para eles poderem ser particionados e dedicados \u00e0s m\u00e1quinas virtuais. Quando o usu\u00e1rio emite uma instru\u00e7\u00e3o de m\u00e1quina virtual que exige mais recursos do ambiente f\u00edsico, o hipervisor retransmite a solicita\u00e7\u00e3o ao sistema f\u00edsico e armazena as mudan\u00e7as em mem\u00f3ria transit\u00f3ria. As m\u00e1quinas virtuais s\u00e3o similares aos servidores f\u00edsicos e agem como eles, o que pode multiplicar as desvantagens de grandes infraestruturas de sistema operacional e das depend\u00eancias da aplica\u00e7\u00e3o. Na maioria das vezes, essas infraestruturas n\u00e3o s\u00e3o necess\u00e1rias para executar uma aplica\u00e7\u00e3o ou microsservi\u00e7os. Cont\u00eaineres : Os cont\u00eaineres armazenam um microsservi\u00e7o ou aplica\u00e7\u00e3o, al\u00e9m de todos os elementos necess\u00e1rios para execut\u00e1-los. Tudo que eles cont\u00eam \u00e9 mantido em um recurso chamado imagem: um arquivo baseado em c\u00f3digo que inclui todas as bibliotecas e depend\u00eancias. Pense nesses arquivos como uma instala\u00e7\u00e3o da distribui\u00e7\u00e3o Linux, j\u00e1 que a imagem inclui pacotes RPM e arquivos de configura\u00e7\u00e3o. Como os cont\u00eaineres s\u00e3o muito pequenos, geralmente h\u00e1 centenas deles levemente acoplados. J\u00e1 que sabemos a diferen\u00e7a entre VM e Cont\u00eaineres, precisamos entender aonde essa solu\u00e7\u00e3o se encaixa, pois, com as mudan\u00e7as que a tecnologia traz no decorrer da sua hist\u00f3ria, \u00e9 preciso entender as novas pr\u00e1ticas de TI com as tradicionais para chegamos a um ponto-chave dessa pergunta: As novas pr\u00e1ticas de TI (desenvolvimento nativo em nuvem, CI/CD e DevOps) existem gra\u00e7as \u00e0 divis\u00e3o das cargas de trabalho nas menores unidades \u00fateis poss\u00edveis, que geralmente s\u00e3o uma fun\u00e7\u00e3o ou um microsservi\u00e7o. Essas unidades s\u00e3o melhor empacotadas em cont\u00eaineres. Assim, v\u00e1rias equipes podem trabalhar em partes separadas de uma aplica\u00e7\u00e3o ou servi\u00e7o sem interromper, ou p\u00f4r em risco o c\u00f3digo empacotado em outros cont\u00eaineres. Nas arquiteturas de TI tradicionais (monol\u00edticas e legadas), todos os elementos de uma carga de trabalho s\u00e3o mantidos em um arquivo grande que n\u00e3o pode ser dividido. Por isso, ele precisa ser empacotado como uma unidade completa em um ambiente maior, frequentemente uma m\u00e1quina virtual. Era comum criar e executar uma aplica\u00e7\u00e3o inteira dentro de uma m\u00e1quina virtual, mesmo sabendo que ao armazenar todo o c\u00f3digo e depend\u00eancias, ela ficava grande demais, e isso poderia gerar falhas em cascata e downtime durante as atualiza\u00e7\u00f5es.","title":"Como cont\u00eaineres funcionam?"},{"location":"#se-aprofundando-um-pouco-mais-nos-conteineres","text":"Se em algum momento voc\u00ea j\u00e1 usou uma VM, imagino que tenha passado pelo processo de baixa uma SO, seja Linux ou Windows e alocando os recursos conforme a capacidade do hardware dispon\u00edvel, ent\u00e3o esse processo dos Cont\u00eaineres pode parecer meio confuso, para isso deixei duas perguntas que precisamos responder antes de cont\u00ednua. Se n\u00e3o \u00e9 uma virtualiza\u00e7\u00e3o como ocorre o isolamento? Como ocorre a divis\u00e3o de recursos?","title":"Se aprofundando um pouco mais nos Cont\u00eaineres"},{"location":"#se-nao-e-uma-virtualizacao-como-ocorre-o-isolamento","text":"Existe uma palavra importante, que resolve essa quest\u00e3o Namespaces , permitindo que os cont\u00eaineres consigam isolamento em determinados n\u00edveis que s\u00e3o: PID : Isola os processos rodando dentro do cont\u00eainer NET : Isola as interfaces de redes IPC : Isola a comunica\u00e7\u00e3o entre processos e memoria MNT : Isola o ponto de montagem UTS : Isola o Kernel, ou seja, simula um novo host(usu\u00e1rio) USER : Isola os arquivos do sistema Dentre esse processo o mais importante, \u00e9 o UTS, o respons\u00e1vel pelo isolamento dos cont\u00eaineres, ao simular um novo host, ele usar o Kernel da m\u00e1quina f\u00edsica para o processamento, por\u00e9m isoladamente. Os namespaces fazem parte do kernel do Linux desde 2002, os namespaces s\u00e3o respons\u00e1veis por gerar o isolamento de grupos de processos em seu n\u00edvel l\u00f3gico.","title":"Se n\u00e3o \u00e9 uma virtualiza\u00e7\u00e3o como ocorre o isolamento?"},{"location":"#como-ocorre-a-divisao-de-recursos","text":"O gerenciamento de recursos, tem a palavra Cgroups para resolver essa demanda de gerenciar, seja ela automaticamente ou manualmente. Os cgroups fornecem os recursos: Limites de recursos : voc\u00ea pode configurar um cgroup para limitar quanto de um determinado recurso (mem\u00f3ria ou CPU, por exemplo) um processo pode usar. Prioriza\u00e7\u00e3o : Voc\u00ea pode controlar quanto de um recurso (CPU, disco ou rede) um processo pode usar em compara\u00e7\u00e3o com processos em outro cgroup quando h\u00e1 conten\u00e7\u00e3o de recursos. Contabilidade : os limites de recursos s\u00e3o monitorados e relatados no n\u00edvel do cgroup. Controle : Voc\u00ea pode alterar o status (congelado, interrompido ou reiniciado) de todos os processos em um cgroup com um \u00fanico comando. Os cgroups s\u00e3o um componente-chave dos cont\u00eaineres porque geralmente h\u00e1 v\u00e1rios processos em execu\u00e7\u00e3o em um cont\u00eainer que precisam ser controlados juntos. Agora que entendemos o significado de cont\u00eaineres, temos mais duas palavras importantes para aprender: Kubernetes Swarm Essas duas palavras possuem uma frase em comum: orquestra\u00e7\u00e3o de containers","title":"Como ocorre a divis\u00e3o de recursos?"},{"location":"#para-que-serve-a-orquestracao-de-conteineres","text":"Basicamente, a orquestra\u00e7\u00e3o de cont\u00eaineres automatiza a implanta\u00e7\u00e3o, o gerenciamento, a escala e a rede dos cont\u00eaineres. Use a orquestra\u00e7\u00e3o de cont\u00eaineres para automatizar e gerenciar tarefas como: Provisionamento e implanta\u00e7\u00e3o Configura\u00e7\u00e3o e programa\u00e7\u00e3o Aloca\u00e7\u00e3o de recursos Disponibilidade dos containers Escala ou remo\u00e7\u00e3o de containers com base no balanceamento de cargas de trabalho na infraestrutura Balanceamento de carga e roteamento de tr\u00e1fego Monitoramento da integridade do container Configura\u00e7\u00e3o da aplica\u00e7\u00e3o com base no container em que ela ser\u00e1 executada Prote\u00e7\u00e3o das intera\u00e7\u00f5es entre os containers As ferramentas de orquestra\u00e7\u00e3o de cont\u00eaineres fornecem um framework para gerenciar arquiteturas de microsservi\u00e7os e cont\u00eaineres em escala. Muitas delas podem ser usadas no gerenciamento do ciclo de vida dos cont\u00eaineres. Algumas op\u00e7\u00f5es s\u00e3o o Kubernetes, Docker Swarm e Apache Mesos, DC/SO e N\u00f4made. Nesse tema vamos aborda sobre e praticar: Docker Docker Swarm: Cluster do Docker Kubernetes Cluster Plano de controle Kubelet Pod Google Kubernetes Amazon Kubernetes Azure Kubernetes","title":"Para que serve a orquestra\u00e7\u00e3o de cont\u00eaineres?"},{"location":"#fontes-usadas-para-elaboracao-desse-conteudo","text":"Red Hat: Cont\u00eaineres vs Vms Red Hat: Orquestra\u00e7\u00e3o de containers etcd: O que s\u00e3o namespaces e cgroups","title":"Fontes usadas para elabora\u00e7\u00e3o desse conte\u00fado"},{"location":"docker/compose/","text":"Compose o que \u00e9? \u00b6 O docker compose \u00e9 uma ferramenta desenvolvida para ajudar a definir e compartilhar aplicativos de v\u00e1rios cont\u00eaineres. A grande vantagem de usar o Compose \u00e9 que voc\u00ea pode definir todos os aplicativos em um arquivo, mant\u00ea-la na raiz do reposit\u00f3rio do seu projeto (agora com controle de vers\u00e3o) e permitir que outra pessoa contribua facilmente para o seu projeto. Algu\u00e9m precisaria apenas clonar seu reposit\u00f3rio e iniciar o aplicativo de composi\u00e7\u00e3o. Na verdade, voc\u00ea pode ver alguns projetos no GitHub/GitLab fazendo exatamente isso agora. O arquivo de defini\u00e7\u00e3o do Docker Compose \u00e9 o local onde \u00e9 especificado todo o ambiente (rede, volume e servi\u00e7os), ele \u00e9 escrito seguindo o formato YAML. Esse arquivo por padr\u00e3o tem como nome docker-compose.yml. O que \u00e9 o YAML? \u00b6 YAML \u00e9 uma linguagem de serializa\u00e7\u00e3o de dados que \u00e9 frequentemente usada para gravar arquivos de configura\u00e7\u00e3o. Dependendo de quem voc\u00ea pergunta, YAML significa ainda outra linguagem de marca\u00e7\u00e3o ou YAML n\u00e3o \u00e9 uma linguagem de marca\u00e7\u00e3o (um acr\u00f4nimo recursivo), que enfatiza que YAML \u00e9 para dados, n\u00e3o documentos. YAML \u00e9 uma linguagem de programa\u00e7\u00e3o popular porque \u00e9 leg\u00edvel e f\u00e1cil de entender. Tamb\u00e9m pode ser usado em conjunto com outras linguagens de programa\u00e7\u00e3o. Instalando o Docker-Compose \u00b6 Windows Mac Linux O docker compose \u00e9 instalado junto ao docker docker-compose O docker compose \u00e9 instalado junto ao docker docker-compose No linux, basta seguir a documenta\u00e7\u00e3o Se houve instala\u00e7\u00e3o via Snap ou Flatpak, o docker compose precisa usar a mesma via Ap\u00f3s a instala\u00e7\u00e3o docker-compose Anatomia do docker-compose.yml \u00b6 O padr\u00e3o YAML utiliza a indenta\u00e7\u00e3o como separador dos blocos de c\u00f3digos das defini\u00e7\u00f5es, por conta disso o uso da indenta\u00e7\u00e3o \u00e9 um fator muito importante, ou seja, caso n\u00e3o a utilize corretamente, o docker-compose falhar\u00e1 em sua execu\u00e7\u00e3o. Cada linha desse arquivo pode ser definida com uma chave valor ou uma lista. Nesse caso, vamos usar a imagem que criamos: Crie uma pasta Crie um arquivo chamado docker-compose.yml na pasta Copiei e cole: version : \"1\" services : flask_web : image : sposigor/app-flask-teste:1 ports : - 5000:5000 Abra o terminal na pasta, que est\u00e1 o arquivo docker-compose.yml e execute: docker-compose up -d Ilustra\u00e7\u00e3o usando o docker-compose up V\u00e1 em localhost:5000 para verificar. Ai est\u00e1 a m\u00e1gica do compose, com um simples documento yml, podemos configurar nosso cont\u00eaineres para rodar com um simples comando e para finalizar: docker-compose down Vou deixar a documenta\u00e7\u00e3o da docker para todas as possibilidades da estrutura docker github \u00e9 importante ler, n\u00e3o fique preocupado com todas as especifica\u00e7\u00f5es, geralmente com algumas \u00e9 o suficiente para subir o cont\u00eainer a partir do .yml. Pare de fazer confus\u00e3o com o Docker Compose Vamos brincar um pouco com o compose \u00b6 Agora que voc\u00ea entendeu um pouco sobre o compose, vou deixar alguns exemplos de arquivos docker-compose.yml. MySQL PostgresSQL PostgresSQL + pgadmin version : \"1\" services : db : image : mysql:8.0-oracle restart : always environment : MYSQL_DATABASE : 'db' MYSQL_USER : 'user' MYSQL_PASSWORD : 'password' MYSQL_ROOT_PASSWORD : 'password' ports : - '3306:3306' expose : - '3306' volumes : - my-db:/var/lib/mysql volumes : my-db : Use um editor sql de sua preferencia e fa\u00e7a a conex\u00e3o. version : '1' services : postgres-compose : image : postgres:14.-alpine restart : always environment : - POSTGRES_USER=postgres - POSTGRES_PASSWORD=postgres ports : - '5432:5432' volumes : - db:/var/lib/postgresql/data volumes : db : driver : local Use um editor sql de sua preferencia e fa\u00e7a a conex\u00e3o. version : '1' services : postgres-compose : image : postgres:14.2-alpine environment : POSTGRES_USERNAME : \"postgres\" POSTGRES_PASSWORD : \"postgres\" ports : - \"5432:5432\" volumes : - db:/var/lib/postgresql/data networks : - postgres-compose-network pgadmin-compose : image : dpage/pgadmin4 environment : PGADMIN_DEFAULT_EMAIL : \"qualquer@email.com\" PGADMIN_DEFAULT_PASSWORD : \"postgres\" ports : - \"1515:80\" depends_on : - postgres-compose networks : - postgres-compose-network volumes : db : driver : local networks : postgres-compose-network : driver : bridge V\u00e1 no localhost:1515 login: qualquer@email.com Senha: postgres Pronto mais uma conex\u00e3o bem sucedida Al\u00e9m disso, recomendo verificar esse reposit\u00f3rio da docker com m\u00faltiplos exemplos awesome-compose Tente bastante, repita cada passo, crie suas varia\u00e7\u00f5es.","title":"Docker Compose"},{"location":"docker/compose/#compose-o-que-e","text":"O docker compose \u00e9 uma ferramenta desenvolvida para ajudar a definir e compartilhar aplicativos de v\u00e1rios cont\u00eaineres. A grande vantagem de usar o Compose \u00e9 que voc\u00ea pode definir todos os aplicativos em um arquivo, mant\u00ea-la na raiz do reposit\u00f3rio do seu projeto (agora com controle de vers\u00e3o) e permitir que outra pessoa contribua facilmente para o seu projeto. Algu\u00e9m precisaria apenas clonar seu reposit\u00f3rio e iniciar o aplicativo de composi\u00e7\u00e3o. Na verdade, voc\u00ea pode ver alguns projetos no GitHub/GitLab fazendo exatamente isso agora. O arquivo de defini\u00e7\u00e3o do Docker Compose \u00e9 o local onde \u00e9 especificado todo o ambiente (rede, volume e servi\u00e7os), ele \u00e9 escrito seguindo o formato YAML. Esse arquivo por padr\u00e3o tem como nome docker-compose.yml.","title":"Compose o que \u00e9?"},{"location":"docker/compose/#o-que-e-o-yaml","text":"YAML \u00e9 uma linguagem de serializa\u00e7\u00e3o de dados que \u00e9 frequentemente usada para gravar arquivos de configura\u00e7\u00e3o. Dependendo de quem voc\u00ea pergunta, YAML significa ainda outra linguagem de marca\u00e7\u00e3o ou YAML n\u00e3o \u00e9 uma linguagem de marca\u00e7\u00e3o (um acr\u00f4nimo recursivo), que enfatiza que YAML \u00e9 para dados, n\u00e3o documentos. YAML \u00e9 uma linguagem de programa\u00e7\u00e3o popular porque \u00e9 leg\u00edvel e f\u00e1cil de entender. Tamb\u00e9m pode ser usado em conjunto com outras linguagens de programa\u00e7\u00e3o.","title":"O que \u00e9 o YAML?"},{"location":"docker/compose/#instalando-o-docker-compose","text":"Windows Mac Linux O docker compose \u00e9 instalado junto ao docker docker-compose O docker compose \u00e9 instalado junto ao docker docker-compose No linux, basta seguir a documenta\u00e7\u00e3o Se houve instala\u00e7\u00e3o via Snap ou Flatpak, o docker compose precisa usar a mesma via Ap\u00f3s a instala\u00e7\u00e3o docker-compose","title":"Instalando o Docker-Compose"},{"location":"docker/compose/#anatomia-do-docker-composeyml","text":"O padr\u00e3o YAML utiliza a indenta\u00e7\u00e3o como separador dos blocos de c\u00f3digos das defini\u00e7\u00f5es, por conta disso o uso da indenta\u00e7\u00e3o \u00e9 um fator muito importante, ou seja, caso n\u00e3o a utilize corretamente, o docker-compose falhar\u00e1 em sua execu\u00e7\u00e3o. Cada linha desse arquivo pode ser definida com uma chave valor ou uma lista. Nesse caso, vamos usar a imagem que criamos: Crie uma pasta Crie um arquivo chamado docker-compose.yml na pasta Copiei e cole: version : \"1\" services : flask_web : image : sposigor/app-flask-teste:1 ports : - 5000:5000 Abra o terminal na pasta, que est\u00e1 o arquivo docker-compose.yml e execute: docker-compose up -d Ilustra\u00e7\u00e3o usando o docker-compose up V\u00e1 em localhost:5000 para verificar. Ai est\u00e1 a m\u00e1gica do compose, com um simples documento yml, podemos configurar nosso cont\u00eaineres para rodar com um simples comando e para finalizar: docker-compose down Vou deixar a documenta\u00e7\u00e3o da docker para todas as possibilidades da estrutura docker github \u00e9 importante ler, n\u00e3o fique preocupado com todas as especifica\u00e7\u00f5es, geralmente com algumas \u00e9 o suficiente para subir o cont\u00eainer a partir do .yml. Pare de fazer confus\u00e3o com o Docker Compose","title":"Anatomia do docker-compose.yml"},{"location":"docker/compose/#vamos-brincar-um-pouco-com-o-compose","text":"Agora que voc\u00ea entendeu um pouco sobre o compose, vou deixar alguns exemplos de arquivos docker-compose.yml. MySQL PostgresSQL PostgresSQL + pgadmin version : \"1\" services : db : image : mysql:8.0-oracle restart : always environment : MYSQL_DATABASE : 'db' MYSQL_USER : 'user' MYSQL_PASSWORD : 'password' MYSQL_ROOT_PASSWORD : 'password' ports : - '3306:3306' expose : - '3306' volumes : - my-db:/var/lib/mysql volumes : my-db : Use um editor sql de sua preferencia e fa\u00e7a a conex\u00e3o. version : '1' services : postgres-compose : image : postgres:14.-alpine restart : always environment : - POSTGRES_USER=postgres - POSTGRES_PASSWORD=postgres ports : - '5432:5432' volumes : - db:/var/lib/postgresql/data volumes : db : driver : local Use um editor sql de sua preferencia e fa\u00e7a a conex\u00e3o. version : '1' services : postgres-compose : image : postgres:14.2-alpine environment : POSTGRES_USERNAME : \"postgres\" POSTGRES_PASSWORD : \"postgres\" ports : - \"5432:5432\" volumes : - db:/var/lib/postgresql/data networks : - postgres-compose-network pgadmin-compose : image : dpage/pgadmin4 environment : PGADMIN_DEFAULT_EMAIL : \"qualquer@email.com\" PGADMIN_DEFAULT_PASSWORD : \"postgres\" ports : - \"1515:80\" depends_on : - postgres-compose networks : - postgres-compose-network volumes : db : driver : local networks : postgres-compose-network : driver : bridge V\u00e1 no localhost:1515 login: qualquer@email.com Senha: postgres Pronto mais uma conex\u00e3o bem sucedida Al\u00e9m disso, recomendo verificar esse reposit\u00f3rio da docker com m\u00faltiplos exemplos awesome-compose Tente bastante, repita cada passo, crie suas varia\u00e7\u00f5es.","title":"Vamos brincar um pouco com o compose"},{"location":"docker/docker_hub/","text":"O que \u00e9 o Docker Hub? \ud83e\udd14 \u00b6 Para exemplificar, o Docker Hub \u00e9 um reposit\u00f3rio que possui imagens para o docker Para acessar Docker Hub Na p\u00e1gina inicial, pesquisaremos o hello-world. Pesquise e chegaremos nessa p\u00e1gina hello-world L\u00e1 encontraremos uma refer\u00eancia e informa\u00e7\u00f5es importantes Tamb\u00e9m repare que existe uma op\u00e7\u00e3o de fazer um pull, ou seja, baixa a imagem localmente Existe um selo oficial das imagens que est\u00e3o no docker hub: Quando for necess\u00e1rio pesquise a imagem. Ubuntu: um SO \u2b50 \u00b6 Realizaremos um exerc\u00edcio Fa\u00e7a o pull da imagem do Ubuntu docker pull ubuntu Rode a imagem no docker docker run ubuntu Ap\u00f3s ter realizado a etapa 1 e 2, porque a interface do Ubuntu n\u00e3o apareceu? Agora temos mais perguntas que respostas. Porque o Cont\u00eainer n\u00e3o rodou que nem o hello-world Se rodou o que o docker run fez ent\u00e3o?","title":"Docker Hub"},{"location":"docker/docker_hub/#o-que-e-o-docker-hub","text":"Para exemplificar, o Docker Hub \u00e9 um reposit\u00f3rio que possui imagens para o docker Para acessar Docker Hub Na p\u00e1gina inicial, pesquisaremos o hello-world. Pesquise e chegaremos nessa p\u00e1gina hello-world L\u00e1 encontraremos uma refer\u00eancia e informa\u00e7\u00f5es importantes Tamb\u00e9m repare que existe uma op\u00e7\u00e3o de fazer um pull, ou seja, baixa a imagem localmente Existe um selo oficial das imagens que est\u00e3o no docker hub: Quando for necess\u00e1rio pesquise a imagem.","title":"O que \u00e9 o Docker Hub? \ud83e\udd14"},{"location":"docker/docker_hub/#ubuntu-um-so","text":"Realizaremos um exerc\u00edcio Fa\u00e7a o pull da imagem do Ubuntu docker pull ubuntu Rode a imagem no docker docker run ubuntu Ap\u00f3s ter realizado a etapa 1 e 2, porque a interface do Ubuntu n\u00e3o apareceu? Agora temos mais perguntas que respostas. Porque o Cont\u00eainer n\u00e3o rodou que nem o hello-world Se rodou o que o docker run fez ent\u00e3o?","title":"Ubuntu: um SO \u2b50"},{"location":"docker/fluxo_containers/","text":"Fluxo de Cria\u00e7\u00e3o do Cont\u00eainer \u00b6 Vamos retorna para nossas perguntas Porque o Cont\u00eainer n\u00e3o rodou que nem o hello-world Se rodou o que o docker run fez ent\u00e3o? Para tentar responder vamos explorar mais alguns comandos do docker. Execute a fun\u00e7\u00e3o ps do docker para observar a lista dos cont\u00eaineres que est\u00e3o rodando docker ps Mesmo ap\u00f3s ter dado o comando docker run ubuntu, o docker ps somente retorna o cabe\u00e7alho da listagem, ou seja, n\u00e3o h\u00e1 nenhum cont\u00eainer em execu\u00e7\u00e3o. CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Bem, se o docker ps n\u00e3o mostrou, tem um comando mais verboso para explicitar a listagem: docker container ls O docker cont\u00eainer ls lista os cont\u00eaineres como o ps. Por\u00e9m, o resultado foi o mesmo, para resolver, devemos acrescentar o verbo -a. docker ps docker container ls docker ps -a docker container ls -a Ap\u00f3s a execu\u00e7\u00e3o a sa\u00edda, vai ser parecida com essa: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 65adb2cb2cd5 ubuntu \"bash\" 4 seconds ago Exited ( 0 ) 4 seconds ago competent_thompson f690741c0bc7 ubuntu \"bash\" 47 seconds ago Exited ( 0 ) 47 seconds ago infallible_williams 6914d474838d hello-world \"/hello\" 2 hours ago Exited ( 0 ) 2 hours ago upbeat_lichterman Ent\u00e3o vamos entender o significado de cada cabe\u00e7alho. CONTAINER ID : \u00c9 o ID do cont\u00eainer, identifica\u00e7\u00e3o. IMAGE : \u00c9 a imagem do cont\u00eainer. COMMAND : \u00c9 o comando que est\u00e1 setado para executar CREATED : \u00c9 o tempo que passou ap\u00f3s a cria\u00e7\u00e3o STATUS : \u00c9 a lista de status created, restarting, running, removing, paused, exited. PORTS : \u00c9 a porta da rede que o docker est\u00e1 rodando, exemplo 8080 NAMES : S\u00e3o os nomes dos cont\u00eaineres Al\u00e9m disso, \u00e9 poss\u00edvel visualizar mais op\u00e7\u00f5es com o comando docker ps e docker container ls . Voltando para as quest\u00f5es \u00b6 Ent\u00e3o conforme a sa\u00edda do comando, o ubuntu subiu a imagem, executou o comando bash e finalizou. Certo, que tal, alterarmos o comando padr\u00e3o? Vamos pedir aquela ajuda do --help docker run --help Agora que retornou algumas op\u00e7\u00f5es para o comando, temos tamb\u00e9m a sintaxe do comando que \u00e9: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Interessante, nessa sintaxe est\u00e1 dizendo que podemos executar comandos da imagem, no caso do ubuntu, podemos usar o terminal. docker run ubuntu sleep 2m Pedir para o ubuntu rodar um sleep de 2 minutos para verificamos o status desse novo cont\u00eainer. Ap\u00f3s enviar o comando ele travou o terminal, significa que est\u00e1 rodando. Abra uma nova aba do terminal e execute um docker ps -a para observar a sa\u00edda CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bb1bf42f3fc3 ubuntu \"sleep 2m\" 18 seconds ago Up 17 seconds frosty_ishizaka 65adb2cb2cd5 ubuntu \"bash\" 25 minutes ago Exited ( 0 ) 25 minutes ago competent_thompson f690741c0bc7 ubuntu \"bash\" 25 minutes ago Exited ( 0 ) 25 minutes ago infallible_williams 6914d474838d hello-world \"/hello\" 3 hours ago Exited ( 0 ) 3 hours ago upbeat_lichterman Op\u00e1, ai est\u00e1, o comando mudou, e o cont\u00eainer est\u00e1 com um status diferente Up , est\u00e1 indicando que est\u00e1 rodando. Comandos \u00dateis \u00b6 Certo, agora entendemos um pouco do fluxo que o docker faz para rodar uma imagem. Agora vamos aprender mais alguns comandos para auxiliar nessa jornada. Volte no terminal e execute: docker run ubuntu sleep 5m Ele vai congelar o terminal, abra uma nova aba ou terminal e execute o docker ps para visualizar o cont\u00eainer que est\u00e1 ativo e agora vamos parar esse cont\u00eainer que est\u00e1 em execu\u00e7\u00e3o. Execute agora o docker stop , mas passe o CONTAINER ID no seu terminal. docker stop 19bf7322160d Ap\u00f3s a execu\u00e7\u00e3o do comando ele vai parar o cont\u00eainer que estava ativo, para visualizar docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 19bf7322160d ubuntu \"sleep 5m\" 41 seconds ago Exited ( 137 ) 7 seconds ago wizardly_shtern bb1bf42f3fc3 ubuntu \"sleep 2m\" 15 minutes ago Exited ( 0 ) 13 minutes ago frosty_ishizaka 65adb2cb2cd5 ubuntu \"bash\" 40 minutes ago Exited ( 0 ) 40 minutes ago competent_thompson f690741c0bc7 ubuntu \"bash\" 40 minutes ago Exited ( 0 ) 40 minutes ago infallible_williams 6914d474838d hello-world \"/hello\" 3 hours ago Exited ( 0 ) 3 hours ago upbeat_lichterman Bem o stop para a execu\u00e7\u00e3o, que tal tentamos o docker start , basta passar o CONTAINER ID para iniciar o cont\u00eainer novamente: docker start 19bf7322160d Ele retorna o CONTAINER ID, basta executar o docker ps para validar que est\u00e1 rodando novamente, com isso voc\u00ea pode pausar com stop e reiniciar um cont\u00eainer com start. Mas, ainda n\u00e3o interagimos com o terminal do ubuntu, para conseguimos acessar o terminal do cont\u00eainer, vamos usar o comando docker exec , mas antes de executar vamos verificar o --help? docker exec --help Ele vai retorna a sintaxe e as op\u00e7\u00f5es, mas vamos verificar a sintaxe primeiro. docker exec [OPTIONS] CONTAINER COMMAND [ARG...] Ele est\u00e1 nos dizendo que al\u00e9m das op\u00e7\u00f5es que nos forneceu, podemos d\u00e1 um comando no cont\u00eainer e que precisamos do CONTAINER ID, vamos tentar? Veja se tem algum cont\u00eainer com a imagem do ubuntu ativa, se n\u00e3o, ative usando o start. Agora verifique no ps e vamos l\u00e1. docker exec -it 19bf7322160d bash O que estou falando para o docker? Que a gente quer executar um comando interativo -i e alocar um pseudo-terminal -t no CONTAINER ID e executa o bash. Agora no seu terminal, deve est\u00e1 vendo a linha de comando do cont\u00eainer que voc\u00ea ativou. Nesse momento voc\u00ea deve est\u00e1 vendo algo +- assim: Legal n\u00e9, agora temos vamos falar do docker pause , podemos pausa um cont\u00eainer ativo: docker pause 19bf7322160d E para sair da pausa, vamos usar o docker unpause docker unpause 19bf7322160d Que tal removemos o cont\u00eainer que est\u00e1 inativo? Para isso vamos usar o docker rm docker rm 19bf7322160d Com isso voc\u00ea pode fazer a remo\u00e7\u00e3o dos cont\u00eaineres. Agora que aprendeu uns comandos novos \ud83d\ude42 \u00b6 Por \u00faltimo, que tal fazemos aquele: docker run ubuntu Contudo, sabemos agora que o que acontece quando o fazemos, vamos adicionar uma op\u00e7\u00e3o nesse comando, vamos inserir as op\u00e7\u00f5es -i e -t no comando para rodar o ubuntu e observar o que acontece. docker run -it ubuntu bash E agora nosso comando run, gerou o resultado que est\u00e1vamos esperando. Voc\u00ea est\u00e1 no terminal do cont\u00eainer. Portas \u00b6 Vamos acessar uma imagem um pouco diferente agora, j\u00e1 vimos um hello world e um SO, vamos ver um site est\u00e1tico imagem , voc\u00ea j\u00e1 deve saber o que \u00e9 preciso para rodar essa imagem, repita os passos: docker pull dockersamples/static-site Antes de usamos o docker run, vamos passar o comando -d, para ele n\u00e3o congelar no terminal enquanto usamos: docker run -d dockersamples/static-site Apos finalizar a execu\u00e7\u00e3o do comando, fa\u00e7a um docker ps para observar o resultado: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26040d6c5529 dockersamples/static-site \"/bin/sh -c 'cd /usr\u2026\" 9 seconds ago Up 8 seconds 80 /tcp, 443 /tcp nervous_goldberg Perceba que temos agora uma informa\u00e7\u00e3o em PORTS , ele est\u00e1 dizendo que est\u00e1 dispon\u00edvel na porta 80, vamos verificar? No seu navegador: localhost:80 O navegador retorna um erro, vamos tentar a porta 443 e o resultado \u00e9 o mesmo, porque n\u00e3o conseguimos ver? Por causa da estrutura de isolamento dos cont\u00eaineres, n\u00e3o devemos esquecer que o isolamento est\u00e1 presente. Para resolver isso, remover o cont\u00eainer que acabamos de criar e passa a op\u00e7\u00e3o --force. docker rm 26040d6c5529 --force Ap\u00f3s a execu\u00e7\u00e3o, vamos passa mais uma op\u00e7\u00e3o para o comando run o -P que vai explicitar as portas e redirecionar automaticamente as portas do cont\u00eainer para as portas da nossa maquina: docker run -d -P dockersamples/static-site Use o docker ps para observar a sa\u00edda, e em PORTS a sa\u00edda est\u00e1 um pouco diferente, para visualizamos com mais clareza, vamos usar o docker port . docker port ca557128fd50 E a sa\u00edda vai ser \u00b1 assim: 443 /tcp -> 0 .0.0.0:49153 443 /tcp -> :::49153 80 /tcp -> 0 .0.0.0:49154 80 /tcp -> :::49154 A porta 443 foi redirecionada para a porta 49153 do nosso sistema e a 80 para 49154, por padr\u00e3o a porta 443 e 80 s\u00e3o sempre liberadas no cont\u00eaineres, vamos verificar? No navegador: localhost:49154 E a resposta do navegador vai ser essa aqui: Al\u00e9m do -P tamb\u00e9m tem o -p, que permite que fa\u00e7amos o mapeamento espec\u00edfico da porta, vamos tentar? Antes vou remover o cont\u00eainer atual: docker rm ca557128fd50 --force E vamos usar o comando: docker -d -p 8080 :80 dockersamples/static-site Explicando o que fiz, passei a porta 8080 da minha maquina, para refletir a porta 80 do cont\u00eainer.","title":"Fluxo"},{"location":"docker/fluxo_containers/#fluxo-de-criacao-do-conteiner","text":"Vamos retorna para nossas perguntas Porque o Cont\u00eainer n\u00e3o rodou que nem o hello-world Se rodou o que o docker run fez ent\u00e3o? Para tentar responder vamos explorar mais alguns comandos do docker. Execute a fun\u00e7\u00e3o ps do docker para observar a lista dos cont\u00eaineres que est\u00e3o rodando docker ps Mesmo ap\u00f3s ter dado o comando docker run ubuntu, o docker ps somente retorna o cabe\u00e7alho da listagem, ou seja, n\u00e3o h\u00e1 nenhum cont\u00eainer em execu\u00e7\u00e3o. CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Bem, se o docker ps n\u00e3o mostrou, tem um comando mais verboso para explicitar a listagem: docker container ls O docker cont\u00eainer ls lista os cont\u00eaineres como o ps. Por\u00e9m, o resultado foi o mesmo, para resolver, devemos acrescentar o verbo -a. docker ps docker container ls docker ps -a docker container ls -a Ap\u00f3s a execu\u00e7\u00e3o a sa\u00edda, vai ser parecida com essa: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 65adb2cb2cd5 ubuntu \"bash\" 4 seconds ago Exited ( 0 ) 4 seconds ago competent_thompson f690741c0bc7 ubuntu \"bash\" 47 seconds ago Exited ( 0 ) 47 seconds ago infallible_williams 6914d474838d hello-world \"/hello\" 2 hours ago Exited ( 0 ) 2 hours ago upbeat_lichterman Ent\u00e3o vamos entender o significado de cada cabe\u00e7alho. CONTAINER ID : \u00c9 o ID do cont\u00eainer, identifica\u00e7\u00e3o. IMAGE : \u00c9 a imagem do cont\u00eainer. COMMAND : \u00c9 o comando que est\u00e1 setado para executar CREATED : \u00c9 o tempo que passou ap\u00f3s a cria\u00e7\u00e3o STATUS : \u00c9 a lista de status created, restarting, running, removing, paused, exited. PORTS : \u00c9 a porta da rede que o docker est\u00e1 rodando, exemplo 8080 NAMES : S\u00e3o os nomes dos cont\u00eaineres Al\u00e9m disso, \u00e9 poss\u00edvel visualizar mais op\u00e7\u00f5es com o comando docker ps e docker container ls .","title":"Fluxo de Cria\u00e7\u00e3o do Cont\u00eainer"},{"location":"docker/fluxo_containers/#voltando-para-as-questoes","text":"Ent\u00e3o conforme a sa\u00edda do comando, o ubuntu subiu a imagem, executou o comando bash e finalizou. Certo, que tal, alterarmos o comando padr\u00e3o? Vamos pedir aquela ajuda do --help docker run --help Agora que retornou algumas op\u00e7\u00f5es para o comando, temos tamb\u00e9m a sintaxe do comando que \u00e9: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Interessante, nessa sintaxe est\u00e1 dizendo que podemos executar comandos da imagem, no caso do ubuntu, podemos usar o terminal. docker run ubuntu sleep 2m Pedir para o ubuntu rodar um sleep de 2 minutos para verificamos o status desse novo cont\u00eainer. Ap\u00f3s enviar o comando ele travou o terminal, significa que est\u00e1 rodando. Abra uma nova aba do terminal e execute um docker ps -a para observar a sa\u00edda CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bb1bf42f3fc3 ubuntu \"sleep 2m\" 18 seconds ago Up 17 seconds frosty_ishizaka 65adb2cb2cd5 ubuntu \"bash\" 25 minutes ago Exited ( 0 ) 25 minutes ago competent_thompson f690741c0bc7 ubuntu \"bash\" 25 minutes ago Exited ( 0 ) 25 minutes ago infallible_williams 6914d474838d hello-world \"/hello\" 3 hours ago Exited ( 0 ) 3 hours ago upbeat_lichterman Op\u00e1, ai est\u00e1, o comando mudou, e o cont\u00eainer est\u00e1 com um status diferente Up , est\u00e1 indicando que est\u00e1 rodando.","title":"Voltando para as quest\u00f5es"},{"location":"docker/fluxo_containers/#comandos-uteis","text":"Certo, agora entendemos um pouco do fluxo que o docker faz para rodar uma imagem. Agora vamos aprender mais alguns comandos para auxiliar nessa jornada. Volte no terminal e execute: docker run ubuntu sleep 5m Ele vai congelar o terminal, abra uma nova aba ou terminal e execute o docker ps para visualizar o cont\u00eainer que est\u00e1 ativo e agora vamos parar esse cont\u00eainer que est\u00e1 em execu\u00e7\u00e3o. Execute agora o docker stop , mas passe o CONTAINER ID no seu terminal. docker stop 19bf7322160d Ap\u00f3s a execu\u00e7\u00e3o do comando ele vai parar o cont\u00eainer que estava ativo, para visualizar docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 19bf7322160d ubuntu \"sleep 5m\" 41 seconds ago Exited ( 137 ) 7 seconds ago wizardly_shtern bb1bf42f3fc3 ubuntu \"sleep 2m\" 15 minutes ago Exited ( 0 ) 13 minutes ago frosty_ishizaka 65adb2cb2cd5 ubuntu \"bash\" 40 minutes ago Exited ( 0 ) 40 minutes ago competent_thompson f690741c0bc7 ubuntu \"bash\" 40 minutes ago Exited ( 0 ) 40 minutes ago infallible_williams 6914d474838d hello-world \"/hello\" 3 hours ago Exited ( 0 ) 3 hours ago upbeat_lichterman Bem o stop para a execu\u00e7\u00e3o, que tal tentamos o docker start , basta passar o CONTAINER ID para iniciar o cont\u00eainer novamente: docker start 19bf7322160d Ele retorna o CONTAINER ID, basta executar o docker ps para validar que est\u00e1 rodando novamente, com isso voc\u00ea pode pausar com stop e reiniciar um cont\u00eainer com start. Mas, ainda n\u00e3o interagimos com o terminal do ubuntu, para conseguimos acessar o terminal do cont\u00eainer, vamos usar o comando docker exec , mas antes de executar vamos verificar o --help? docker exec --help Ele vai retorna a sintaxe e as op\u00e7\u00f5es, mas vamos verificar a sintaxe primeiro. docker exec [OPTIONS] CONTAINER COMMAND [ARG...] Ele est\u00e1 nos dizendo que al\u00e9m das op\u00e7\u00f5es que nos forneceu, podemos d\u00e1 um comando no cont\u00eainer e que precisamos do CONTAINER ID, vamos tentar? Veja se tem algum cont\u00eainer com a imagem do ubuntu ativa, se n\u00e3o, ative usando o start. Agora verifique no ps e vamos l\u00e1. docker exec -it 19bf7322160d bash O que estou falando para o docker? Que a gente quer executar um comando interativo -i e alocar um pseudo-terminal -t no CONTAINER ID e executa o bash. Agora no seu terminal, deve est\u00e1 vendo a linha de comando do cont\u00eainer que voc\u00ea ativou. Nesse momento voc\u00ea deve est\u00e1 vendo algo +- assim: Legal n\u00e9, agora temos vamos falar do docker pause , podemos pausa um cont\u00eainer ativo: docker pause 19bf7322160d E para sair da pausa, vamos usar o docker unpause docker unpause 19bf7322160d Que tal removemos o cont\u00eainer que est\u00e1 inativo? Para isso vamos usar o docker rm docker rm 19bf7322160d Com isso voc\u00ea pode fazer a remo\u00e7\u00e3o dos cont\u00eaineres.","title":"Comandos \u00dateis"},{"location":"docker/fluxo_containers/#agora-que-aprendeu-uns-comandos-novos","text":"Por \u00faltimo, que tal fazemos aquele: docker run ubuntu Contudo, sabemos agora que o que acontece quando o fazemos, vamos adicionar uma op\u00e7\u00e3o nesse comando, vamos inserir as op\u00e7\u00f5es -i e -t no comando para rodar o ubuntu e observar o que acontece. docker run -it ubuntu bash E agora nosso comando run, gerou o resultado que est\u00e1vamos esperando. Voc\u00ea est\u00e1 no terminal do cont\u00eainer.","title":"Agora que aprendeu uns comandos novos \ud83d\ude42"},{"location":"docker/fluxo_containers/#portas","text":"Vamos acessar uma imagem um pouco diferente agora, j\u00e1 vimos um hello world e um SO, vamos ver um site est\u00e1tico imagem , voc\u00ea j\u00e1 deve saber o que \u00e9 preciso para rodar essa imagem, repita os passos: docker pull dockersamples/static-site Antes de usamos o docker run, vamos passar o comando -d, para ele n\u00e3o congelar no terminal enquanto usamos: docker run -d dockersamples/static-site Apos finalizar a execu\u00e7\u00e3o do comando, fa\u00e7a um docker ps para observar o resultado: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26040d6c5529 dockersamples/static-site \"/bin/sh -c 'cd /usr\u2026\" 9 seconds ago Up 8 seconds 80 /tcp, 443 /tcp nervous_goldberg Perceba que temos agora uma informa\u00e7\u00e3o em PORTS , ele est\u00e1 dizendo que est\u00e1 dispon\u00edvel na porta 80, vamos verificar? No seu navegador: localhost:80 O navegador retorna um erro, vamos tentar a porta 443 e o resultado \u00e9 o mesmo, porque n\u00e3o conseguimos ver? Por causa da estrutura de isolamento dos cont\u00eaineres, n\u00e3o devemos esquecer que o isolamento est\u00e1 presente. Para resolver isso, remover o cont\u00eainer que acabamos de criar e passa a op\u00e7\u00e3o --force. docker rm 26040d6c5529 --force Ap\u00f3s a execu\u00e7\u00e3o, vamos passa mais uma op\u00e7\u00e3o para o comando run o -P que vai explicitar as portas e redirecionar automaticamente as portas do cont\u00eainer para as portas da nossa maquina: docker run -d -P dockersamples/static-site Use o docker ps para observar a sa\u00edda, e em PORTS a sa\u00edda est\u00e1 um pouco diferente, para visualizamos com mais clareza, vamos usar o docker port . docker port ca557128fd50 E a sa\u00edda vai ser \u00b1 assim: 443 /tcp -> 0 .0.0.0:49153 443 /tcp -> :::49153 80 /tcp -> 0 .0.0.0:49154 80 /tcp -> :::49154 A porta 443 foi redirecionada para a porta 49153 do nosso sistema e a 80 para 49154, por padr\u00e3o a porta 443 e 80 s\u00e3o sempre liberadas no cont\u00eaineres, vamos verificar? No navegador: localhost:49154 E a resposta do navegador vai ser essa aqui: Al\u00e9m do -P tamb\u00e9m tem o -p, que permite que fa\u00e7amos o mapeamento espec\u00edfico da porta, vamos tentar? Antes vou remover o cont\u00eainer atual: docker rm ca557128fd50 --force E vamos usar o comando: docker -d -p 8080 :80 dockersamples/static-site Explicando o que fiz, passei a porta 8080 da minha maquina, para refletir a porta 80 do cont\u00eainer.","title":"Portas"},{"location":"docker/imagem/","text":"O que \u00e9 a imagem \u00b6 Pense nela como um conjunto de instru\u00e7\u00f5es para criar um cont\u00eainer no docker, como um modelo. A imagem do docker, cont\u00e9m c\u00f3digo de aplicativo, bibliotecas, ferramentas, depend\u00eancias e outros arquivos necess\u00e1rios para executar um aplicativo. Quando um usu\u00e1rio executa uma imagem, ela pode se tornar uma ou v\u00e1rias inst\u00e2ncias de um cont\u00eainer. As imagens do Docker t\u00eam v\u00e1rias camadas, cada uma se originando da camada anterior, mas difere dela. As camadas aceleram as compila\u00e7\u00f5es do Docker enquanto aumentam a capacidade de reutiliza\u00e7\u00e3o e diminuem o uso do disco. Camadas de imagem tamb\u00e9m s\u00e3o arquivos somente (leitura). Depois que um cont\u00eainer \u00e9 criado, uma camada grav\u00e1vel \u00e9 adicionada sobre as imagens imut\u00e1veis, permitindo que o usu\u00e1rio fa\u00e7a altera\u00e7\u00f5es. Sabemos sobre o docker hub e o sobre fluxo dos cont\u00eaineres, voc\u00ea deve estar se perguntando se \u00e9 poss\u00edvel ter nossa pr\u00f3pria imagem e para responder, vamos come\u00e7ar com o comando docker images . docker images Vai ter um retorno das imagens dispon\u00edveis localmente REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 54c9d81cbb44 4 weeks ago 72 .8MB postgres latest da2cb49d7a8d 4 weeks ago 374MB dpage/pgadmin4 latest e52ca07eba62 7 weeks ago 272MB hello-world latest feb5d9fea6a5 5 months ago 13 .3kB dockersamples/static-site latest f589ccde7957 5 years ago 190MB Vamos entender o cabe\u00e7alho: REPOSITORY : \u00c9 o reposit\u00f3rio da imagem TAG : \u00c9 a tag, geralmente associada a vers\u00e3o IMAGE ID : \u00c9 o ID da imagem, n\u00e3o confunda com o ID do cont\u00eainer CREATED : Data da cria\u00e7\u00e3o da imagem SIZE : Tamanho da imagem Copie o IMAGE ID de uma das suas imagens locais e vamos usar o comando docker inspect . docker inspect 54c9d81cbb44 A sa\u00edda retorna um JSON array por padr\u00e3o, mostrando informa\u00e7\u00f5es sobre a imagem, antes de continuamos, vamos observar o docker history . docker history 54c9d81cbb44 E ela vai retorna uma lista, o que \u00e9 essa lista? S\u00e3o a camadas que quando unidas(amarrado) formam a imagem do docker que usamos. E \u00e9 poss\u00edvel usar essas camadas em outras imagens docker, o que significa isso? Quando fazemos um pull de uma imagem, ele, na verdade, est\u00e1 baixando essas camadas, e o modelo(imagem) \u00e9 o respons\u00e1vel por unificar elas para formar o resultado, ent\u00e3o se voc\u00ea baixa uma imagem nova ela aproveitar as camadas que j\u00e1 est\u00e3o dispon\u00edveis, que fazem parte do seu modelo(imagem), e baixam somente as camadas que faltam. Essa reutiliza\u00e7\u00e3o otimiza o espa\u00e7o e evitar que ocorra duplica\u00e7\u00e3o de camadas. Criando nossa primeira imagem \u00b6 Para continuar a explica\u00e7\u00e3o da cria\u00e7\u00e3o da vamos apresentar uma nova categoria de arquivo, o dockerfile . Esse processo de cria\u00e7\u00e3o de imagem \u00e9 um pouco confuso, mas leia a documenta\u00e7\u00e3o do dockerfile para facilitar na compreens\u00e3o. Nesse processo vou subir uma aplica\u00e7\u00e3o flask. Fa\u00e7a uma pasta para esse projeto. Criar um arquivo chamado app.py na pasta. Crie uma pasta chamada templates na pasta do projeto. E por \u00faltimo um index.html na pasta templates. app.py index.html from flask import Flask , render_template import os app = Flask ( __name__ ) @app . route ( '/' ) def home (): return render_template ( 'index.html' ) if __name__ == \"__main__\" : port = int ( os . environ . get ( 'PORT' , 5000 )) app . run ( debug = True , host = '0.0.0.0' , port = port ) <!DOCTYPE html> < html lang = \"\" > < head > < meta charset = \"UTF-8\" > < title > Flask no Docker </ title > </ head > < body > < h1 > Eu amo Docker </ h1 > </ body > </ html > Se quiser mudar fazer altera\u00e7\u00e3o no html fique a vontade. Dentro do arquivo requirements.txt, insira: click == 8 .0.3 colorama == 0 .4.4 Flask == 2 .0.2 itsdangerous == 2 .0.1 Jinja2 == 3 .0.3 MarkupSafe == 2 .0.1 Werkzeug == 2 .0.2 gunicorn == 20 .1.0 S\u00f3 mais uma coisa, por padr\u00e3o o flask usa a porta 5000, ent\u00e3o vamos guarda essa informa\u00e7\u00e3o para depois. Dockerfile \u00b6 Crie um arquivo chamado Dockerfile na pasta do projeto. Insira no Dockerfile: # Iniciando a image do Python FROM python:3.10-alpine3.15 # Copiando o requirements para o /app da imagem COPY requirements.txt /app/requirements.txt # Expor a porta 5000 da aplica\u00e7\u00e3o flask EXPOSE 5000 # Mudando para pasta de trabalho WORKDIR /app # instalando as libs do requirements RUN pip install -r requirements.txt # Copiando o restante do conteudo no /app da imagem COPY . /app # Configurando o enrtypoint para rodar o python ENTRYPOINT [ \"python\" ] CMD [ \"app.py\" ] Antes de continuar com o processo, vou listar os comandos que usei no dockerfile para compreender esse processo que estamos fazendo. FROM python:3.10-alpine3.15 O comando FROM fala para o docker que estou buscando uma imagem, a imagem do python , e ele fornece essa estrutura do python para usamos, como base nesse processo. Lembrando que j\u00e1 existe milhares de imagens no docker hub. WORKDIR /app Aqui estamos dizendo ao docker qual pasta usar para continuar o processo de cria\u00e7\u00e3o da imagem. O comando WORKDIR \u00e9 o local de trabalho que ele deve usar. COPY requirements.txt /app/requirements.txt RUN pip install -r requirements.txt O comando COPY, diz para copiar o conte\u00fado do nosso diret\u00f3rio, no caso o requirements.txt para o diret\u00f3rio da imagem e em seguida executar o pip para instalar o requirements.txt. COPY . /app Continuando com a c\u00f3pia, agora copiamos o restante dos arquivos em nosso diret\u00f3rio de trabalho local para o diret\u00f3rio na imagem docker. ENTRYPOINT [ \"python\" ] ENTRYPOINT este \u00e9 o comando que executa a aplica\u00e7\u00e3o no cont\u00eainer. CMD [ \"app.py\" ] CMD anexa a lista de par\u00e2metros ao par\u00e2metro EntryPoint para executar o comando que executa o aplicativo. J\u00e1 revisamos o arquivo Dockerfile, est\u00e1 na hora de subir efetivamente a imagem, vamos usar um comando chamado docker build . Abra o terminal a partir da pasta que deve est\u00e1 com essa estrutura: app_web_flask \u251c\u2500\u2500 app.py \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 templates \u251c\u2500\u2500 index.html Com o terminal, aberto a partir da pasta vamos executar esse comando docker build -t univesp-github/app-flask-teste:1 . Antes de executar vamos compreender, toda essa instru\u00e7\u00e3o, o -t \u00e9 para nomear a imagem. O :1 para a vers\u00e3o da nossa imagem e o ponto no final para dizer que queremos que seja feito o build a partir do diret\u00f3rio atual. Para alterar o nome da imagem basta substituir o univesp-github/app-flask-teste . Na execu\u00e7\u00e3o ele roda o Dockerfiler, baixa as camadas do python e depois criar uma camada com a estrutura que criamos, para verificar, primeiro vamos dar um docker imagens : REPOSITORY TAG IMAGE ID CREATED SIZE univesp-github/app-flask-teste 1 0c1acf96e7e1 About a minute ago 126MB python 3 .10-slim-buster 41471b406cc5 4 days ago 115MB ubuntu latest 54c9d81cbb44 4 weeks ago 72 .8MB postgres latest da2cb49d7a8d 4 weeks ago 374MB dpage/pgadmin4 latest e52ca07eba62 7 weeks ago 272MB hello-world latest feb5d9fea6a5 5 months ago 13 .3kB dockersamples/static-site latest f589ccde7957 5 years ago 190MB E l\u00e1 est\u00e1 nossa imagem rec\u00e9m-criada, lembrando que a porta que o flask redireciona \u00e9 a porta 5000, para manter o padr\u00e3o vamos direcionar para porta 5000 da nossa maquina. docker run -d -p 5000 :5000 univesp-github/app-flask-teste:1 Agora no navegador, acessar a porta 5000. localhost:5000 Espero que tenha entendido o processo de cria\u00e7\u00e3o de imagem, lembrando que a documenta\u00e7\u00e3o dockerfile , as vari\u00e1veis que podemos inserir no Dockerfiler podem nos ajudar na constru\u00e7\u00e3o de imagens mais completas. Subindo a imagem para o Docker Hub \u00b6 Esse processo vai disponibilizar a imagem que fizemos, no reposit\u00f3rio do docker hub. Fa\u00e7a login em docker hub Fa\u00e7a login no terminal, para isso execute o comando docker login -u ap\u00f3s o -u inserir o seu nome de usu\u00e1rio. O terminal vai solicitar sua senha. Exemplo: docker login -u sposigor Logado no terminal, vamos realizar o docker push . Antes de continuar com o push, devemos corrigir o nome da imagem para o docker hub aceitar. Vamos usar o docker tag . Nome atual da imagem : univesp-github/app-flask-teste Nome alterado da imagem : seu usuario/app-flask-teste Com esse ajuste, vamos subir a imagem no reposit\u00f3rio atrelado ao usu\u00e1rio, se voc\u00ea logou no docker hub, deve ter observado o reposit\u00f3rio da sua conta. docker tag univesp-github/app-flask-teste:1 sposigor/app-flask-teste:1 N\u00e3o esque\u00e7a da vers\u00e3o, assim que a execu\u00e7\u00e3o finalizar, verifique as imagens docker images , observe a altera\u00e7\u00e3o e vamos fazer o push dessa imagem. docker push sposigor/app-flask-teste:1 V\u00e1 novamente no reposit\u00f3rio e veja sua imagem dispon\u00edvel. Para visualizar o resultado do meu push app-flask-teste .","title":"Imagem"},{"location":"docker/imagem/#o-que-e-a-imagem","text":"Pense nela como um conjunto de instru\u00e7\u00f5es para criar um cont\u00eainer no docker, como um modelo. A imagem do docker, cont\u00e9m c\u00f3digo de aplicativo, bibliotecas, ferramentas, depend\u00eancias e outros arquivos necess\u00e1rios para executar um aplicativo. Quando um usu\u00e1rio executa uma imagem, ela pode se tornar uma ou v\u00e1rias inst\u00e2ncias de um cont\u00eainer. As imagens do Docker t\u00eam v\u00e1rias camadas, cada uma se originando da camada anterior, mas difere dela. As camadas aceleram as compila\u00e7\u00f5es do Docker enquanto aumentam a capacidade de reutiliza\u00e7\u00e3o e diminuem o uso do disco. Camadas de imagem tamb\u00e9m s\u00e3o arquivos somente (leitura). Depois que um cont\u00eainer \u00e9 criado, uma camada grav\u00e1vel \u00e9 adicionada sobre as imagens imut\u00e1veis, permitindo que o usu\u00e1rio fa\u00e7a altera\u00e7\u00f5es. Sabemos sobre o docker hub e o sobre fluxo dos cont\u00eaineres, voc\u00ea deve estar se perguntando se \u00e9 poss\u00edvel ter nossa pr\u00f3pria imagem e para responder, vamos come\u00e7ar com o comando docker images . docker images Vai ter um retorno das imagens dispon\u00edveis localmente REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest 54c9d81cbb44 4 weeks ago 72 .8MB postgres latest da2cb49d7a8d 4 weeks ago 374MB dpage/pgadmin4 latest e52ca07eba62 7 weeks ago 272MB hello-world latest feb5d9fea6a5 5 months ago 13 .3kB dockersamples/static-site latest f589ccde7957 5 years ago 190MB Vamos entender o cabe\u00e7alho: REPOSITORY : \u00c9 o reposit\u00f3rio da imagem TAG : \u00c9 a tag, geralmente associada a vers\u00e3o IMAGE ID : \u00c9 o ID da imagem, n\u00e3o confunda com o ID do cont\u00eainer CREATED : Data da cria\u00e7\u00e3o da imagem SIZE : Tamanho da imagem Copie o IMAGE ID de uma das suas imagens locais e vamos usar o comando docker inspect . docker inspect 54c9d81cbb44 A sa\u00edda retorna um JSON array por padr\u00e3o, mostrando informa\u00e7\u00f5es sobre a imagem, antes de continuamos, vamos observar o docker history . docker history 54c9d81cbb44 E ela vai retorna uma lista, o que \u00e9 essa lista? S\u00e3o a camadas que quando unidas(amarrado) formam a imagem do docker que usamos. E \u00e9 poss\u00edvel usar essas camadas em outras imagens docker, o que significa isso? Quando fazemos um pull de uma imagem, ele, na verdade, est\u00e1 baixando essas camadas, e o modelo(imagem) \u00e9 o respons\u00e1vel por unificar elas para formar o resultado, ent\u00e3o se voc\u00ea baixa uma imagem nova ela aproveitar as camadas que j\u00e1 est\u00e3o dispon\u00edveis, que fazem parte do seu modelo(imagem), e baixam somente as camadas que faltam. Essa reutiliza\u00e7\u00e3o otimiza o espa\u00e7o e evitar que ocorra duplica\u00e7\u00e3o de camadas.","title":"O que \u00e9 a imagem"},{"location":"docker/imagem/#criando-nossa-primeira-imagem","text":"Para continuar a explica\u00e7\u00e3o da cria\u00e7\u00e3o da vamos apresentar uma nova categoria de arquivo, o dockerfile . Esse processo de cria\u00e7\u00e3o de imagem \u00e9 um pouco confuso, mas leia a documenta\u00e7\u00e3o do dockerfile para facilitar na compreens\u00e3o. Nesse processo vou subir uma aplica\u00e7\u00e3o flask. Fa\u00e7a uma pasta para esse projeto. Criar um arquivo chamado app.py na pasta. Crie uma pasta chamada templates na pasta do projeto. E por \u00faltimo um index.html na pasta templates. app.py index.html from flask import Flask , render_template import os app = Flask ( __name__ ) @app . route ( '/' ) def home (): return render_template ( 'index.html' ) if __name__ == \"__main__\" : port = int ( os . environ . get ( 'PORT' , 5000 )) app . run ( debug = True , host = '0.0.0.0' , port = port ) <!DOCTYPE html> < html lang = \"\" > < head > < meta charset = \"UTF-8\" > < title > Flask no Docker </ title > </ head > < body > < h1 > Eu amo Docker </ h1 > </ body > </ html > Se quiser mudar fazer altera\u00e7\u00e3o no html fique a vontade. Dentro do arquivo requirements.txt, insira: click == 8 .0.3 colorama == 0 .4.4 Flask == 2 .0.2 itsdangerous == 2 .0.1 Jinja2 == 3 .0.3 MarkupSafe == 2 .0.1 Werkzeug == 2 .0.2 gunicorn == 20 .1.0 S\u00f3 mais uma coisa, por padr\u00e3o o flask usa a porta 5000, ent\u00e3o vamos guarda essa informa\u00e7\u00e3o para depois.","title":"Criando nossa primeira imagem"},{"location":"docker/imagem/#dockerfile","text":"Crie um arquivo chamado Dockerfile na pasta do projeto. Insira no Dockerfile: # Iniciando a image do Python FROM python:3.10-alpine3.15 # Copiando o requirements para o /app da imagem COPY requirements.txt /app/requirements.txt # Expor a porta 5000 da aplica\u00e7\u00e3o flask EXPOSE 5000 # Mudando para pasta de trabalho WORKDIR /app # instalando as libs do requirements RUN pip install -r requirements.txt # Copiando o restante do conteudo no /app da imagem COPY . /app # Configurando o enrtypoint para rodar o python ENTRYPOINT [ \"python\" ] CMD [ \"app.py\" ] Antes de continuar com o processo, vou listar os comandos que usei no dockerfile para compreender esse processo que estamos fazendo. FROM python:3.10-alpine3.15 O comando FROM fala para o docker que estou buscando uma imagem, a imagem do python , e ele fornece essa estrutura do python para usamos, como base nesse processo. Lembrando que j\u00e1 existe milhares de imagens no docker hub. WORKDIR /app Aqui estamos dizendo ao docker qual pasta usar para continuar o processo de cria\u00e7\u00e3o da imagem. O comando WORKDIR \u00e9 o local de trabalho que ele deve usar. COPY requirements.txt /app/requirements.txt RUN pip install -r requirements.txt O comando COPY, diz para copiar o conte\u00fado do nosso diret\u00f3rio, no caso o requirements.txt para o diret\u00f3rio da imagem e em seguida executar o pip para instalar o requirements.txt. COPY . /app Continuando com a c\u00f3pia, agora copiamos o restante dos arquivos em nosso diret\u00f3rio de trabalho local para o diret\u00f3rio na imagem docker. ENTRYPOINT [ \"python\" ] ENTRYPOINT este \u00e9 o comando que executa a aplica\u00e7\u00e3o no cont\u00eainer. CMD [ \"app.py\" ] CMD anexa a lista de par\u00e2metros ao par\u00e2metro EntryPoint para executar o comando que executa o aplicativo. J\u00e1 revisamos o arquivo Dockerfile, est\u00e1 na hora de subir efetivamente a imagem, vamos usar um comando chamado docker build . Abra o terminal a partir da pasta que deve est\u00e1 com essa estrutura: app_web_flask \u251c\u2500\u2500 app.py \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 templates \u251c\u2500\u2500 index.html Com o terminal, aberto a partir da pasta vamos executar esse comando docker build -t univesp-github/app-flask-teste:1 . Antes de executar vamos compreender, toda essa instru\u00e7\u00e3o, o -t \u00e9 para nomear a imagem. O :1 para a vers\u00e3o da nossa imagem e o ponto no final para dizer que queremos que seja feito o build a partir do diret\u00f3rio atual. Para alterar o nome da imagem basta substituir o univesp-github/app-flask-teste . Na execu\u00e7\u00e3o ele roda o Dockerfiler, baixa as camadas do python e depois criar uma camada com a estrutura que criamos, para verificar, primeiro vamos dar um docker imagens : REPOSITORY TAG IMAGE ID CREATED SIZE univesp-github/app-flask-teste 1 0c1acf96e7e1 About a minute ago 126MB python 3 .10-slim-buster 41471b406cc5 4 days ago 115MB ubuntu latest 54c9d81cbb44 4 weeks ago 72 .8MB postgres latest da2cb49d7a8d 4 weeks ago 374MB dpage/pgadmin4 latest e52ca07eba62 7 weeks ago 272MB hello-world latest feb5d9fea6a5 5 months ago 13 .3kB dockersamples/static-site latest f589ccde7957 5 years ago 190MB E l\u00e1 est\u00e1 nossa imagem rec\u00e9m-criada, lembrando que a porta que o flask redireciona \u00e9 a porta 5000, para manter o padr\u00e3o vamos direcionar para porta 5000 da nossa maquina. docker run -d -p 5000 :5000 univesp-github/app-flask-teste:1 Agora no navegador, acessar a porta 5000. localhost:5000 Espero que tenha entendido o processo de cria\u00e7\u00e3o de imagem, lembrando que a documenta\u00e7\u00e3o dockerfile , as vari\u00e1veis que podemos inserir no Dockerfiler podem nos ajudar na constru\u00e7\u00e3o de imagens mais completas.","title":"Dockerfile"},{"location":"docker/imagem/#subindo-a-imagem-para-o-docker-hub","text":"Esse processo vai disponibilizar a imagem que fizemos, no reposit\u00f3rio do docker hub. Fa\u00e7a login em docker hub Fa\u00e7a login no terminal, para isso execute o comando docker login -u ap\u00f3s o -u inserir o seu nome de usu\u00e1rio. O terminal vai solicitar sua senha. Exemplo: docker login -u sposigor Logado no terminal, vamos realizar o docker push . Antes de continuar com o push, devemos corrigir o nome da imagem para o docker hub aceitar. Vamos usar o docker tag . Nome atual da imagem : univesp-github/app-flask-teste Nome alterado da imagem : seu usuario/app-flask-teste Com esse ajuste, vamos subir a imagem no reposit\u00f3rio atrelado ao usu\u00e1rio, se voc\u00ea logou no docker hub, deve ter observado o reposit\u00f3rio da sua conta. docker tag univesp-github/app-flask-teste:1 sposigor/app-flask-teste:1 N\u00e3o esque\u00e7a da vers\u00e3o, assim que a execu\u00e7\u00e3o finalizar, verifique as imagens docker images , observe a altera\u00e7\u00e3o e vamos fazer o push dessa imagem. docker push sposigor/app-flask-teste:1 V\u00e1 novamente no reposit\u00f3rio e veja sua imagem dispon\u00edvel. Para visualizar o resultado do meu push app-flask-teste .","title":"Subindo a imagem para o Docker Hub"},{"location":"docker/instala%C3%A7%C3%A3o/","text":"Para Instalar \u2728 \u00b6 Vamos iniciar com a instala\u00e7\u00e3o do docker. Windows Linux Mac A documenta\u00e7\u00e3o: Instala\u00e7\u00e3o no Windows Vou deixa aqui um passo a passo que vai ajudar nesse processo de instala\u00e7\u00e3o no windows. Lembre-se de que o Docker para Windows possui restri\u00e7\u00f5es acerca de utiliza\u00e7\u00e3o e instabilidades, sendo prefer\u00edvel usar a vers\u00e3o para Linux A documenta\u00e7\u00e3o para verificar as distros: Distros Selecione sua distribui\u00e7\u00e3o e continue com a instala\u00e7\u00e3o Tamb\u00e9m \u00e9 possivel usar o repositorio oficial da sua distro e op\u00e7\u00f5es como o Snap e Flatpak non-root user: para rodar o docker no Linux, temos que chamar o sudo todas \u00e0s vezes, para contornar isso aqui documenta\u00e7\u00e3o Ou basta usar o comando: sudo usermod -aG docker $USER A documenta\u00e7\u00e3o: Instala\u00e7\u00e3o no MAC Lembre-se de que o Docker para Mac possui restri\u00e7\u00f5es acerca de utiliza\u00e7\u00e3o e instabilidades, sendo prefer\u00edvel usar a vers\u00e3o para Linux Hello World \ud83e\ude90 \u00b6 Ap\u00f3s a instala\u00e7\u00e3o abra seu terminal e execute: Windows Linux Mac docker run hello-world docker run hello-world Se o erro do docker daemon ocorrer basta acessar a documenta\u00e7\u00e3o Para rodar manualmente o backend, abra o terminal e use o comando: sudo dockerd \u00c9 necess\u00e1rio manter o terminal aberto rodando o backend.] Para finalizar o processo no terminal, ctrl + c docker run hello-world Entendendo o Hello World \u00b6 Se tudo ocorreu bem no hello world na saida vai ser assim: docker run hello-world 126 \u2718 Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:97a379f4f88575512824f3b352bc03cd75e239179eea0fecc38e597b2209f49a Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1 . The Docker client contacted the Docker daemon. 2 . The Docker daemon pulled the \"hello-world\" image from the Docker Hub. ( amd64 ) 3 . The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4 . The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Essa saida nos d\u00e1 informa\u00e7\u00f5es importantes, ent\u00e3o vamos analisar por partes: Unable to find image 'hello-world:latest' locally Esse trecho fala sobre uma imagem que n\u00e3o foi encontrada localmente, o proximo trecho: latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:97a379f4f88575512824f3b352bc03cd75e239179eea0fecc38e597b2209f49a Status: Downloaded newer image for hello-world:latest J\u00e1 nesse trecho o docker est\u00e1 baixando uma imagem de algum lugar e ap\u00f3s isso ele executa o hello world normalmente. Afinal o que aconteceu? \u00b6 Para exemplificar o docker n\u00e3o encontrou a imagem local e baixou de um reposit\u00f3rio, mas qual? Espiar a resposta O reposit\u00f3rio com as imagens \u00e9 o Docker Hub.","title":"Instala\u00e7\u00e3o"},{"location":"docker/instala%C3%A7%C3%A3o/#para-instalar","text":"Vamos iniciar com a instala\u00e7\u00e3o do docker. Windows Linux Mac A documenta\u00e7\u00e3o: Instala\u00e7\u00e3o no Windows Vou deixa aqui um passo a passo que vai ajudar nesse processo de instala\u00e7\u00e3o no windows. Lembre-se de que o Docker para Windows possui restri\u00e7\u00f5es acerca de utiliza\u00e7\u00e3o e instabilidades, sendo prefer\u00edvel usar a vers\u00e3o para Linux A documenta\u00e7\u00e3o para verificar as distros: Distros Selecione sua distribui\u00e7\u00e3o e continue com a instala\u00e7\u00e3o Tamb\u00e9m \u00e9 possivel usar o repositorio oficial da sua distro e op\u00e7\u00f5es como o Snap e Flatpak non-root user: para rodar o docker no Linux, temos que chamar o sudo todas \u00e0s vezes, para contornar isso aqui documenta\u00e7\u00e3o Ou basta usar o comando: sudo usermod -aG docker $USER A documenta\u00e7\u00e3o: Instala\u00e7\u00e3o no MAC Lembre-se de que o Docker para Mac possui restri\u00e7\u00f5es acerca de utiliza\u00e7\u00e3o e instabilidades, sendo prefer\u00edvel usar a vers\u00e3o para Linux","title":"Para Instalar \u2728"},{"location":"docker/instala%C3%A7%C3%A3o/#hello-world","text":"Ap\u00f3s a instala\u00e7\u00e3o abra seu terminal e execute: Windows Linux Mac docker run hello-world docker run hello-world Se o erro do docker daemon ocorrer basta acessar a documenta\u00e7\u00e3o Para rodar manualmente o backend, abra o terminal e use o comando: sudo dockerd \u00c9 necess\u00e1rio manter o terminal aberto rodando o backend.] Para finalizar o processo no terminal, ctrl + c docker run hello-world","title":"Hello World \ud83e\ude90"},{"location":"docker/instala%C3%A7%C3%A3o/#entendendo-o-hello-world","text":"Se tudo ocorreu bem no hello world na saida vai ser assim: docker run hello-world 126 \u2718 Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:97a379f4f88575512824f3b352bc03cd75e239179eea0fecc38e597b2209f49a Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1 . The Docker client contacted the Docker daemon. 2 . The Docker daemon pulled the \"hello-world\" image from the Docker Hub. ( amd64 ) 3 . The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4 . The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Essa saida nos d\u00e1 informa\u00e7\u00f5es importantes, ent\u00e3o vamos analisar por partes: Unable to find image 'hello-world:latest' locally Esse trecho fala sobre uma imagem que n\u00e3o foi encontrada localmente, o proximo trecho: latest: Pulling from library/hello-world 2db29710123e: Pull complete Digest: sha256:97a379f4f88575512824f3b352bc03cd75e239179eea0fecc38e597b2209f49a Status: Downloaded newer image for hello-world:latest J\u00e1 nesse trecho o docker est\u00e1 baixando uma imagem de algum lugar e ap\u00f3s isso ele executa o hello world normalmente.","title":"Entendendo o Hello World"},{"location":"docker/instala%C3%A7%C3%A3o/#afinal-o-que-aconteceu","text":"Para exemplificar o docker n\u00e3o encontrou a imagem local e baixou de um reposit\u00f3rio, mas qual? Espiar a resposta O reposit\u00f3rio com as imagens \u00e9 o Docker Hub.","title":"Afinal o que aconteceu?"},{"location":"docker/redes/","text":"Rede Bridge - Ponte \u00b6 A rede, uma rede de ponte \u00e9 um dispositivo de camada de link que encaminha o tr\u00e1fego entre os segmentos de rede. Uma ponte pode ser um dispositivo de hardware ou um dispositivo de software executado no kernel de uma m\u00e1quina host. No Docker, uma rede de ponte usa uma ponte de software que permite que os cont\u00eaineres conectados \u00e0 mesma rede de ponte se comuniquem, enquanto fornece isolamento de cont\u00eaineres que n\u00e3o est\u00e3o conectados a essa rede de ponte. O driver de ponte do Docker instala automaticamente as regras na m\u00e1quina host para que os cont\u00eaineres em diferentes redes de ponte n\u00e3o possam se comunicar diretamente entre si. As redes de ponte se aplicam a cont\u00eaineres em execu\u00e7\u00e3o no mesmo host do daemon do Docker. Para comunica\u00e7\u00e3o entre cont\u00eaineres em execu\u00e7\u00e3o em diferentes hosts do daemon do Docker, voc\u00ea pode gerenciar o roteamento no n\u00edvel do sistema operacional ou usar uma rede de sobreposi\u00e7\u00e3o. Quando voc\u00ea inicia o Docker, uma rede de ponte padr\u00e3o (tamb\u00e9m chamada Bridge) \u00e9 criada automaticamente e os cont\u00eaineres rec\u00e9m-iniciados se conectam a ela, a menos que especificado de outra forma. Voc\u00ea tamb\u00e9m pode criar redes de ponte personalizadas definidas pelo usu\u00e1rio. As redes de ponte definidas pelo usu\u00e1rio s\u00e3o superiores \u00e0 rede de ponte padr\u00e3o. Realizaremos um teste: execute o docker run -it ubuntu bash , deixei o terminal aberto e abra uma nova aba no terminal Nesse terminal execute docker ps , copie o id do cont\u00eainer e vamos usar o docker inspect docker inspect 8c9e5c315c0f A sa\u00edda vai ser um JSON array e l\u00e1 no final vai esta as informa\u00e7\u00f5es sobre a rede: \"Networks\" : { \"bridge\" : { \"IPAMConfig\" : null , \"Links\" : null , \"Aliases\" : null , \"NetworkID\" : \"f2265fd0f92380df4ff74210e72ae304c76b3720cfb07bb134d97aa6ed215d70\" , \"EndpointID\" : \"86e57b1d3e2f1b3019246d6b50da7d88744c6bdc4acdb62f8b69236d1407185b\" , \"Gateway\" : \"172.17.0.1\" , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"DriverOpts\" : null } Entre todas essas configura\u00e7\u00f5es, temos o NetworkID que \u00e9 a rede do docker0 , ou seja, por padr\u00e3o o docker mant\u00e9m os mesmo para todos os containers NetworkID . Execute o docker network ls para verificar a saida: NETWORK ID NAME DRIVER SCOPE f2265fd0f923 bridge bridge local 95dc365e7cbf host host local 093d70e2475c none null local NETWORK ID : Id da rede NAME : Nome da rede DRIVER : Driver da rede SCOPE : \u00c9 o alcance, com as op\u00e7\u00f5es de local ou global Para mais informa\u00e7\u00f5es docker network . Testando a rede Bridge \u00b6 Para isso, vamos usar dois cont\u00eaineres ubuntu: Ubuntu 1 Ubuntu 2 docker run -it ubuntu bash Quando o bash iniciar: apt-get update E vamos instalar o ping apt-get install iputils-ping -y docker run -it ubuntu bash Assim que o bash iniciar deixei esse ubuntu de lado Precisamos do IP dos cont\u00eaineres, para isso vamos usar docker ps e em seguida o docker inspect Geralmente o Gateway \u00e9 172.17.0.1 e os cont\u00eaineres continuar a numera\u00e7\u00e3o. Fa\u00e7a uma anota\u00e7\u00e3o de qual \u00e9 o cont\u00eainer/IP para usar. Use no ubuntu 1 o comando ping e passe o IP do ubuntu 2. No meu caso a sa\u00edda ficou assim: root@8c9e5c315c0f:/# ping 172 .17.0.2 PING 172 .17.0.2 ( 172 .17.0.2 ) 56 ( 84 ) bytes of data. 64 bytes from 172 .17.0.2: icmp_seq = 1 ttl = 64 time = 0 .313 ms 64 bytes from 172 .17.0.2: icmp_seq = 2 ttl = 64 time = 0 .147 ms 64 bytes from 172 .17.0.2: icmp_seq = 3 ttl = 64 time = 0 .123 ms 64 bytes from 172 .17.0.2: icmp_seq = 4 ttl = 64 time = 0 .151 ms Para finalizar a execu\u00e7\u00e3o basta aperta ctrl + c, e acabamos de usar a rede do docker para realizar a comunica\u00e7\u00e3o entre dois cont\u00eaineres. Melhorando a comunica\u00e7\u00e3o \u00b6 Bem, deve ter percebido que ficar procurando IP dos cont\u00eaineres e anotando cada IP n\u00e3o \u00e9 uma boa ideia, al\u00e9m de que os cont\u00eaineres podem perder a conex\u00e3o ou cair, pensando nesse problema o docker criou uma coluna NAME no cont\u00eaineres e com ela que vamos resolver todo esse problema. Vamos passa a flag --name durante o docker run para nomear nossos cont\u00eaineres e vamos criar nossa rede, \u00e9 um processo bem simples: Usaremos o docker network create para criar uma rede, vamos usar a flag --driver para passar o driver bridge. docker network create --driver bridge rede-teste E vamos passar nossa rede na cria\u00e7\u00e3o do cont\u00eainer: Pong Ping docker run -it --name pong --network rede-teste ubuntu sleep 30m docker run -it --name ubuntu1 --network rede-teste ubuntu bash Quando o bash iniciar: apt-get update E vamos instalar o ping apt-get install iputils-ping -y Execute o ping, mas agora vamos passar o nome do cont\u00eainer e n\u00e3o o IP ping pong A diferen\u00e7a entre o padr\u00e3o do docker bridge network e o user-defined bridges \u00e9 que quando criamos nossa pr\u00f3pria rede bridge, no processo \u00e9 provido uma solu\u00e7\u00e3o DNS autom\u00e1tica nos cont\u00eaineres, possibilitando esse teste que fizemos, sem ocorrer a necessidade de mais configura\u00e7\u00f5es. Quando executamos o docker network ls , verificamos que temos mais duas categorias de drivers de redes dispon\u00edveis, none e host . A rede com o driver none basicamente n\u00e3o criar conex\u00f5es no cont\u00eainer, removendo a interface de rede: docker run -d --network none ubuntu sleep 30m De um docker inspect nesse cont\u00eainer e o resultado: \"Networks\" : { \"none\" : { \"IPAMConfig\" : null , \"Links\" : null , \"Aliases\" : null , \"NetworkID\" : \"093d70e2475c6ddd793426f4f6d3aa5560fd946ae182219aff56b2f406f1d290\" , \"EndpointID\" : \"59be8bf2afca5f2a103aa48fe86a85a676dd8ffe48a4d1101d128dcb5e9ad8b1\" , \"Gateway\" : \"\" , \"IPAddress\" : \"\" , \"IPPrefixLen\" : 0 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"\" , \"DriverOpts\" : null } } Os campos est\u00e3o sem informa\u00e7\u00e3o de IP ou est\u00e3o com null. Isolando completamente o cont\u00eainer. Enquanto o driver host , elimina o isolamento proporcionado pela estrutura do docker, ou seja, acessa a rede diretamente da host machine: docker run -d --network host sposigor/app-flask-teste:1 Se lembra que no projeto o flask define a porta 5000, e para acessar no navegador era preciso passa a flag -p para redirecionar? Com o driver host da rede, basta acessar diretamente, copie e cole no navegador: localhost:5000 Para lembrar ainda \u00e9 poss\u00edvel ter problemas de portas, ou seja, se houve mais alguma aplica\u00e7\u00e3o usando a porta 5000 vai ocorrer um erro.","title":"Rede"},{"location":"docker/redes/#rede-bridge-ponte","text":"A rede, uma rede de ponte \u00e9 um dispositivo de camada de link que encaminha o tr\u00e1fego entre os segmentos de rede. Uma ponte pode ser um dispositivo de hardware ou um dispositivo de software executado no kernel de uma m\u00e1quina host. No Docker, uma rede de ponte usa uma ponte de software que permite que os cont\u00eaineres conectados \u00e0 mesma rede de ponte se comuniquem, enquanto fornece isolamento de cont\u00eaineres que n\u00e3o est\u00e3o conectados a essa rede de ponte. O driver de ponte do Docker instala automaticamente as regras na m\u00e1quina host para que os cont\u00eaineres em diferentes redes de ponte n\u00e3o possam se comunicar diretamente entre si. As redes de ponte se aplicam a cont\u00eaineres em execu\u00e7\u00e3o no mesmo host do daemon do Docker. Para comunica\u00e7\u00e3o entre cont\u00eaineres em execu\u00e7\u00e3o em diferentes hosts do daemon do Docker, voc\u00ea pode gerenciar o roteamento no n\u00edvel do sistema operacional ou usar uma rede de sobreposi\u00e7\u00e3o. Quando voc\u00ea inicia o Docker, uma rede de ponte padr\u00e3o (tamb\u00e9m chamada Bridge) \u00e9 criada automaticamente e os cont\u00eaineres rec\u00e9m-iniciados se conectam a ela, a menos que especificado de outra forma. Voc\u00ea tamb\u00e9m pode criar redes de ponte personalizadas definidas pelo usu\u00e1rio. As redes de ponte definidas pelo usu\u00e1rio s\u00e3o superiores \u00e0 rede de ponte padr\u00e3o. Realizaremos um teste: execute o docker run -it ubuntu bash , deixei o terminal aberto e abra uma nova aba no terminal Nesse terminal execute docker ps , copie o id do cont\u00eainer e vamos usar o docker inspect docker inspect 8c9e5c315c0f A sa\u00edda vai ser um JSON array e l\u00e1 no final vai esta as informa\u00e7\u00f5es sobre a rede: \"Networks\" : { \"bridge\" : { \"IPAMConfig\" : null , \"Links\" : null , \"Aliases\" : null , \"NetworkID\" : \"f2265fd0f92380df4ff74210e72ae304c76b3720cfb07bb134d97aa6ed215d70\" , \"EndpointID\" : \"86e57b1d3e2f1b3019246d6b50da7d88744c6bdc4acdb62f8b69236d1407185b\" , \"Gateway\" : \"172.17.0.1\" , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"DriverOpts\" : null } Entre todas essas configura\u00e7\u00f5es, temos o NetworkID que \u00e9 a rede do docker0 , ou seja, por padr\u00e3o o docker mant\u00e9m os mesmo para todos os containers NetworkID . Execute o docker network ls para verificar a saida: NETWORK ID NAME DRIVER SCOPE f2265fd0f923 bridge bridge local 95dc365e7cbf host host local 093d70e2475c none null local NETWORK ID : Id da rede NAME : Nome da rede DRIVER : Driver da rede SCOPE : \u00c9 o alcance, com as op\u00e7\u00f5es de local ou global Para mais informa\u00e7\u00f5es docker network .","title":"Rede Bridge - Ponte"},{"location":"docker/redes/#testando-a-rede-bridge","text":"Para isso, vamos usar dois cont\u00eaineres ubuntu: Ubuntu 1 Ubuntu 2 docker run -it ubuntu bash Quando o bash iniciar: apt-get update E vamos instalar o ping apt-get install iputils-ping -y docker run -it ubuntu bash Assim que o bash iniciar deixei esse ubuntu de lado Precisamos do IP dos cont\u00eaineres, para isso vamos usar docker ps e em seguida o docker inspect Geralmente o Gateway \u00e9 172.17.0.1 e os cont\u00eaineres continuar a numera\u00e7\u00e3o. Fa\u00e7a uma anota\u00e7\u00e3o de qual \u00e9 o cont\u00eainer/IP para usar. Use no ubuntu 1 o comando ping e passe o IP do ubuntu 2. No meu caso a sa\u00edda ficou assim: root@8c9e5c315c0f:/# ping 172 .17.0.2 PING 172 .17.0.2 ( 172 .17.0.2 ) 56 ( 84 ) bytes of data. 64 bytes from 172 .17.0.2: icmp_seq = 1 ttl = 64 time = 0 .313 ms 64 bytes from 172 .17.0.2: icmp_seq = 2 ttl = 64 time = 0 .147 ms 64 bytes from 172 .17.0.2: icmp_seq = 3 ttl = 64 time = 0 .123 ms 64 bytes from 172 .17.0.2: icmp_seq = 4 ttl = 64 time = 0 .151 ms Para finalizar a execu\u00e7\u00e3o basta aperta ctrl + c, e acabamos de usar a rede do docker para realizar a comunica\u00e7\u00e3o entre dois cont\u00eaineres.","title":"Testando a rede Bridge"},{"location":"docker/redes/#melhorando-a-comunicacao","text":"Bem, deve ter percebido que ficar procurando IP dos cont\u00eaineres e anotando cada IP n\u00e3o \u00e9 uma boa ideia, al\u00e9m de que os cont\u00eaineres podem perder a conex\u00e3o ou cair, pensando nesse problema o docker criou uma coluna NAME no cont\u00eaineres e com ela que vamos resolver todo esse problema. Vamos passa a flag --name durante o docker run para nomear nossos cont\u00eaineres e vamos criar nossa rede, \u00e9 um processo bem simples: Usaremos o docker network create para criar uma rede, vamos usar a flag --driver para passar o driver bridge. docker network create --driver bridge rede-teste E vamos passar nossa rede na cria\u00e7\u00e3o do cont\u00eainer: Pong Ping docker run -it --name pong --network rede-teste ubuntu sleep 30m docker run -it --name ubuntu1 --network rede-teste ubuntu bash Quando o bash iniciar: apt-get update E vamos instalar o ping apt-get install iputils-ping -y Execute o ping, mas agora vamos passar o nome do cont\u00eainer e n\u00e3o o IP ping pong A diferen\u00e7a entre o padr\u00e3o do docker bridge network e o user-defined bridges \u00e9 que quando criamos nossa pr\u00f3pria rede bridge, no processo \u00e9 provido uma solu\u00e7\u00e3o DNS autom\u00e1tica nos cont\u00eaineres, possibilitando esse teste que fizemos, sem ocorrer a necessidade de mais configura\u00e7\u00f5es. Quando executamos o docker network ls , verificamos que temos mais duas categorias de drivers de redes dispon\u00edveis, none e host . A rede com o driver none basicamente n\u00e3o criar conex\u00f5es no cont\u00eainer, removendo a interface de rede: docker run -d --network none ubuntu sleep 30m De um docker inspect nesse cont\u00eainer e o resultado: \"Networks\" : { \"none\" : { \"IPAMConfig\" : null , \"Links\" : null , \"Aliases\" : null , \"NetworkID\" : \"093d70e2475c6ddd793426f4f6d3aa5560fd946ae182219aff56b2f406f1d290\" , \"EndpointID\" : \"59be8bf2afca5f2a103aa48fe86a85a676dd8ffe48a4d1101d128dcb5e9ad8b1\" , \"Gateway\" : \"\" , \"IPAddress\" : \"\" , \"IPPrefixLen\" : 0 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"\" , \"DriverOpts\" : null } } Os campos est\u00e3o sem informa\u00e7\u00e3o de IP ou est\u00e3o com null. Isolando completamente o cont\u00eainer. Enquanto o driver host , elimina o isolamento proporcionado pela estrutura do docker, ou seja, acessa a rede diretamente da host machine: docker run -d --network host sposigor/app-flask-teste:1 Se lembra que no projeto o flask define a porta 5000, e para acessar no navegador era preciso passa a flag -p para redirecionar? Com o driver host da rede, basta acessar diretamente, copie e cole no navegador: localhost:5000 Para lembrar ainda \u00e9 poss\u00edvel ter problemas de portas, ou seja, se houve mais alguma aplica\u00e7\u00e3o usando a porta 5000 vai ocorrer um erro.","title":"Melhorando a comunica\u00e7\u00e3o"},{"location":"docker/volumes/","text":"Gerenciamento de Dados \u00b6 As refer\u00eancias ao espa\u00e7o em disco em imagens e cont\u00eaineres do Docker podem ser confusas. \u00c9 importante distinguir entre armazenamento local e armazenamento virtual. Armazenamento local refere-se ao espa\u00e7o em disco que a camada grav\u00e1vel de um cont\u00eainer usa, enquanto o armazenamento virtual \u00e9 o espa\u00e7o em disco usado para o cont\u00eainer e a camada grav\u00e1vel. A camada somente leitura de uma imagem podem ser compartilhadas entre qualquer cont\u00eainer iniciado a partir da mesma imagem. Que tal verificar essa informa\u00e7\u00e3o? Antes de continuamos, vou limpar minhas imagens e meus cont\u00eaineres que est\u00e3o armazenados, como pode ver: Imagens Cont\u00eaineres REPOSITORY TAG IMAGE ID CREATED SIZE sposigor/app-flask-teste 1 c704ddb7c517 2 hours ago 60 .3MB univesp-github/app-flask-teste 1 c704ddb7c517 2 hours ago 60 .3MB python 3 .10-alpine a0e2910f7263 4 days ago 48 .6MB python 3 .10-slim-buster 41471b406cc5 4 days ago 115MB python 3 .10 e4bdbb3cacf1 4 days ago 917MB ubuntu latest 54c9d81cbb44 4 weeks ago 72 .8MB postgres latest da2cb49d7a8d 4 weeks ago 374MB dpage/pgadmin4 latest e52ca07eba62 7 weeks ago 272MB hello-world latest feb5d9fea6a5 5 months ago 13 .3kB dockersamples/static-site latest f589ccde7957 5 years ago 190MB CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 46cab0670fc8 univesp-github/app-flask-teste:1 \"python app.py\" 2 hours ago Exited ( 0 ) 2 hours ago elegant_brown b50c4ac105c3 f32698e186b5 \"python app.py\" 2 hours ago Exited ( 0 ) 2 hours ago boring_knuth 40ea6243bbc3 64160aa2a8dc \"python app.py\" 2 hours ago Exited ( 0 ) 2 hours ago unruffled_roentgen 7ef49050e8df 1647b4c47b68 \"python app.py\" 2 hours ago Exited ( 0 ) 2 hours ago nostalgic_dirac 19bf7322160d ubuntu \"sleep 5m\" 20 hours ago Exited ( 0 ) 19 hours ago wizardly_shtern bb1bf42f3fc3 ubuntu \"sleep 2m\" 20 hours ago Exited ( 0 ) 20 hours ago frosty_ishizaka 65adb2cb2cd5 ubuntu \"bash\" 20 hours ago Exited ( 0 ) 20 hours ago competent_thompson f690741c0bc7 ubuntu \"bash\" 20 hours ago Exited ( 0 ) 20 hours ago infallible_williams 6914d474838d hello-world \"/hello\" 23 hours ago Exited ( 0 ) 20 hours ago upbeat_lichterman Vou usar um comando um pouco diferente o docker system prune docker system prune -af Ele remove todas as imagens, cont\u00eaineres, volumes e o que mais tiver armazenado no docker, passei o par\u00e2metro -a de all e -f de force. Vou lista mais alguns comandos de remo\u00e7\u00e3o que podem ser uteis: docker container rm : Remove somente com o CONTAINER ID. docker container prune : Remove todos os containeres docker image rm : Remove somente a imagem com o IMAGE ID docker image prune : Remove todas as imagens docker volume rm : Remove o volume com o VOLUME NAME docker volume prune : Remove todos os volumes docker network rm : Remove o network com o NETWORK ID docker network prune : Remove todos os network Para come\u00e7ar a entender melhor o volume, armazenamento local e armazenamento virtual, recorremos ao nosso querido ubuntu, dessa vez, vamos chamar ele duas vezes: Primeira Segunda docker run -it ubuntu bash Assim que subir o bash execute o apt-get update Escreva exit para finalizar docker run -it ubuntu bash Nesse caso apenas e escreva exit para finalizar Com o comando docker ps -as a sa\u00edda: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZE a4928a7ff9a6 ubuntu \"bash\" 47 seconds ago Exited ( 0 ) 44 seconds ago funny_thompson 5B ( virtual 72 .8MB ) 0516c2a0ac00 ubuntu \"bash\" 4 minutes ago Exited ( 130 ) About a minute ago fervent_turing 34MB ( virtual 107MB ) Temos uma nova coluna que \u00e9 a SIZE e ela possui duas informa\u00e7\u00f5es o armazenamento local e armazenamento virtual, usando o ubuntu como exemplo, em um apenas subimos a imagem sendo o primeiro na lista e o segundo fizemos o apt-get update. Armazenamento Local : \u00c9 a camada da qual temos acesso a gravar. Armazenamento Virtual : \u00c9 o tamanho da imagem sem qualquer grava\u00e7\u00e3o. Quando fazemos grava\u00e7\u00f5es, esses dados reflete tanto no armazenamento local quanto no armazenamento virtual. Persist\u00eancia de dados \u00b6 Podemos querer que os dados da nossa aplica\u00e7\u00e3o sejam persistentes, porque assim garantimos que ela esteja distribu\u00edda e dispon\u00edvel se precisarmos consult\u00e1-la. Por\u00e9m, se escrevermos os dados nos cont\u00eaineres, por padr\u00e3o eles n\u00e3o ficar\u00e3o armazenados nesta camada, criada para ser descart\u00e1vel. Existem tr\u00eas possibilidades para contornar esta situa\u00e7\u00e3o com o Docker. Bind Mounts \u00b6 Os bind mounts est\u00e3o dispon\u00edveis no Docker desde seus primeiros dias para a persist\u00eancia de dados. Os bind mounts montar\u00e3o um arquivo ou diret\u00f3rio em seu cont\u00eainer a partir de sua m\u00e1quina host, que voc\u00ea pode referenciar atrav\u00e9s de seu caminho absoluto. Para usar o bind mounts, o arquivo ou diret\u00f3rio n\u00e3o precisa j\u00e1 existir em seu host do Docker. Se n\u00e3o existir, ser\u00e1 criado sob demanda. As montagens de liga\u00e7\u00e3o dependem do sistema de arquivos da m\u00e1quina host ter uma estrutura de diret\u00f3rio espec\u00edfica dispon\u00edvel. Voc\u00ea deve criar explicitamente um caminho para o arquivo ou pasta para colocar o armazenamento. Outra informa\u00e7\u00e3o importante sobre bind mounts \u00e9 que elas d\u00e3o acesso a arquivos confidenciais. Conforme os documentos do Docker, voc\u00ea pode alterar o sistema de arquivos do host atrav\u00e9s de processos executados em um cont\u00eainer. Isso inclui criar, modificar e excluir arquivos e diret\u00f3rios do sistema, que podem ter implica\u00e7\u00f5es de seguran\u00e7a bastante graves. Pode at\u00e9 impactar processos n\u00e3o-Docker. Para come\u00e7ar a usar o bind mounts, precisamos criar uma pasta na nossa maquina, vou cria na \u00e1rea de trabalho e nome\u00e1-la de bind. Copie a localiza\u00e7\u00e3o que vamos usar. -v --mount docker run -v /home/sposigor/bind:/teste -it ubuntu bash docker run -it --mount type = bind,src = /home/sposigor/bind,dst = /teste ubuntu bash A docker recomenda usar --mount e n\u00e3o o -v Se tiver d\u00favidas, na documenta\u00e7\u00e3o do docker run tem mais informa\u00e7\u00f5es. Para realizar o teste: Fa\u00e7a o docker run, seja em -v ou --mount. No bash do cont\u00eainer, de um ls Veja a pasta teste criada e vamos entrar nela com o cd teste/ Na pasta touch teste1.txt e escreva exit para sair V\u00e1 na sua pasta que voc\u00ea criou na m\u00e1quina local e abra ela e o arquivo teste1.txt vai est\u00e1 l\u00e1. Repita o processo de 1 \u00e1 3, com um novo cont\u00eainer e o arquivo criado no cont\u00eainer anterior persiste l\u00e1. Volumes \u00b6 Os volumes s\u00e3o um \u00f3timo mecanismo para adicionar uma camada de persist\u00eancia de dados em seus cont\u00eaineres do Docker, especialmente para uma situa\u00e7\u00e3o em que voc\u00ea precisa persistir dados ap\u00f3s desligar seus cont\u00eaineres. Volumes, portanto \u00e9 a solu\u00e7\u00e3o mais recomendada pelo docker para usar em ambientes de produ\u00e7\u00e3o e afins. O docker volume ls observa os volumes dispon\u00edveis: DRIVER VOLUME NAME DRIVER : \u00c9 o volume do drive VOLUME NAME : \u00c9 o nome do volume Criar um volume novo docker volume create e o nome do volume docker volume create testando Vamos colocar em produ\u00e7\u00e3o: -v --mount docker run -v testando:/teste -it ubuntu bash docker run -t -i --mount type = bind,src = testando,dst = /teste ubuntu bash Fa\u00e7a o docker run, seja em -v ou --mount. No bash do container, de um ls Veja a pasta teste que foi criada e vamos entrar nela com o cd teste/ Dentro da pasta touch teste1.txt e escreva exit para sair Repita o processo de 1 \u00e1 3, com um novo container e o arquivo criado no container anterios persiste l\u00e1. Deve ter surgido uma duvida, aonde est\u00e1 esse arquivo que criei? Para isso vamos para o terminal: No terminal sudo su cd /var/lib/docker/volumes ls para verificar os arquivos O volume criado vai est\u00e1 aqui, cd testando ls vai ter uma pasta _data cd _data e em seguida ls Encontrou o arquivo que foi criado Os volumes do Docker s\u00e3o completamente manipulados pelo pr\u00f3prio Docker e, portanto, independentes da estrutura de diret\u00f3rios e do sistema operacional da m\u00e1quina host. Quando voc\u00ea usa um volume, um novo diret\u00f3rio \u00e9 criado no diret\u00f3rio de armazenamento do Docker na m\u00e1quina host e o Docker gerencia o conte\u00fado desse diret\u00f3rio. Por ultimo podemos passar diretamente do docker run o volume que ele se encarrega de criar -v --mount docker run -v volume_novo:/teste -it ubuntu bash docker run -t -i --mount type = bind,src = volume_novo,dst = /teste ubuntu bash docker volume ls e a sa\u00edda: DRIVER VOLUME NAME local testando local volume_novo tmpfs mounts \u00b6 O tmpfs mounts \u00e9 para espa\u00e7os de armazenamento pequenos e ef\u00eameros que s\u00f3 podem ser usados \u200b\u200bpor um \u00fanico cont\u00eainer, existe o sistema de arquivos tmpfs. Ele \u00e9 apoiado apenas pelo armazenamento RAM no sistema host. Essa funcionalidade s\u00f3 est\u00e1 dispon\u00edvel se voc\u00ea estiver executando o Docker no Linux. Seguindo a ordem para criar um tmpfs \u00e9 mais simples, j\u00e1 possui a pr\u00f3pria flag --tmpfs: docker run -it --tmpfs = /app ubuntu bash Perceba que a pasta app que criamos usando o --tmpfs, est\u00e1 com um fundo verde, assim como o tmp, ent\u00e3o significa que ela \u00e9 tempor\u00e1ria, quando o cont\u00eainer for finalizado, os dados ali s\u00e3o apagados. Ent\u00e3o qual \u00e9 a utilidade de usar o tmpfs? \u00c9 que ela armazena os arquivos na mem\u00f3ria do host e n\u00e3o na camada de escrita do cont\u00eaineres r/w, ou seja, se existem dados sens\u00edveis para serem armazenados no processo e por quest\u00f5es de segura n\u00e3o deseja escrever na camada de escrita do cont\u00eainer r/w, o tmpfs \u00e9 recomendando nessa situa\u00e7\u00e3o. Para mais uma aplica\u00e7\u00e3o podemos usar como par\u00e2metro do --mount: docker run -it --mount type = tmpfs,dst = /teste ubuntu bash","title":"Gerenciamento de Dados"},{"location":"docker/volumes/#gerenciamento-de-dados","text":"As refer\u00eancias ao espa\u00e7o em disco em imagens e cont\u00eaineres do Docker podem ser confusas. \u00c9 importante distinguir entre armazenamento local e armazenamento virtual. Armazenamento local refere-se ao espa\u00e7o em disco que a camada grav\u00e1vel de um cont\u00eainer usa, enquanto o armazenamento virtual \u00e9 o espa\u00e7o em disco usado para o cont\u00eainer e a camada grav\u00e1vel. A camada somente leitura de uma imagem podem ser compartilhadas entre qualquer cont\u00eainer iniciado a partir da mesma imagem. Que tal verificar essa informa\u00e7\u00e3o? Antes de continuamos, vou limpar minhas imagens e meus cont\u00eaineres que est\u00e3o armazenados, como pode ver: Imagens Cont\u00eaineres REPOSITORY TAG IMAGE ID CREATED SIZE sposigor/app-flask-teste 1 c704ddb7c517 2 hours ago 60 .3MB univesp-github/app-flask-teste 1 c704ddb7c517 2 hours ago 60 .3MB python 3 .10-alpine a0e2910f7263 4 days ago 48 .6MB python 3 .10-slim-buster 41471b406cc5 4 days ago 115MB python 3 .10 e4bdbb3cacf1 4 days ago 917MB ubuntu latest 54c9d81cbb44 4 weeks ago 72 .8MB postgres latest da2cb49d7a8d 4 weeks ago 374MB dpage/pgadmin4 latest e52ca07eba62 7 weeks ago 272MB hello-world latest feb5d9fea6a5 5 months ago 13 .3kB dockersamples/static-site latest f589ccde7957 5 years ago 190MB CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 46cab0670fc8 univesp-github/app-flask-teste:1 \"python app.py\" 2 hours ago Exited ( 0 ) 2 hours ago elegant_brown b50c4ac105c3 f32698e186b5 \"python app.py\" 2 hours ago Exited ( 0 ) 2 hours ago boring_knuth 40ea6243bbc3 64160aa2a8dc \"python app.py\" 2 hours ago Exited ( 0 ) 2 hours ago unruffled_roentgen 7ef49050e8df 1647b4c47b68 \"python app.py\" 2 hours ago Exited ( 0 ) 2 hours ago nostalgic_dirac 19bf7322160d ubuntu \"sleep 5m\" 20 hours ago Exited ( 0 ) 19 hours ago wizardly_shtern bb1bf42f3fc3 ubuntu \"sleep 2m\" 20 hours ago Exited ( 0 ) 20 hours ago frosty_ishizaka 65adb2cb2cd5 ubuntu \"bash\" 20 hours ago Exited ( 0 ) 20 hours ago competent_thompson f690741c0bc7 ubuntu \"bash\" 20 hours ago Exited ( 0 ) 20 hours ago infallible_williams 6914d474838d hello-world \"/hello\" 23 hours ago Exited ( 0 ) 20 hours ago upbeat_lichterman Vou usar um comando um pouco diferente o docker system prune docker system prune -af Ele remove todas as imagens, cont\u00eaineres, volumes e o que mais tiver armazenado no docker, passei o par\u00e2metro -a de all e -f de force. Vou lista mais alguns comandos de remo\u00e7\u00e3o que podem ser uteis: docker container rm : Remove somente com o CONTAINER ID. docker container prune : Remove todos os containeres docker image rm : Remove somente a imagem com o IMAGE ID docker image prune : Remove todas as imagens docker volume rm : Remove o volume com o VOLUME NAME docker volume prune : Remove todos os volumes docker network rm : Remove o network com o NETWORK ID docker network prune : Remove todos os network Para come\u00e7ar a entender melhor o volume, armazenamento local e armazenamento virtual, recorremos ao nosso querido ubuntu, dessa vez, vamos chamar ele duas vezes: Primeira Segunda docker run -it ubuntu bash Assim que subir o bash execute o apt-get update Escreva exit para finalizar docker run -it ubuntu bash Nesse caso apenas e escreva exit para finalizar Com o comando docker ps -as a sa\u00edda: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZE a4928a7ff9a6 ubuntu \"bash\" 47 seconds ago Exited ( 0 ) 44 seconds ago funny_thompson 5B ( virtual 72 .8MB ) 0516c2a0ac00 ubuntu \"bash\" 4 minutes ago Exited ( 130 ) About a minute ago fervent_turing 34MB ( virtual 107MB ) Temos uma nova coluna que \u00e9 a SIZE e ela possui duas informa\u00e7\u00f5es o armazenamento local e armazenamento virtual, usando o ubuntu como exemplo, em um apenas subimos a imagem sendo o primeiro na lista e o segundo fizemos o apt-get update. Armazenamento Local : \u00c9 a camada da qual temos acesso a gravar. Armazenamento Virtual : \u00c9 o tamanho da imagem sem qualquer grava\u00e7\u00e3o. Quando fazemos grava\u00e7\u00f5es, esses dados reflete tanto no armazenamento local quanto no armazenamento virtual.","title":"Gerenciamento de Dados"},{"location":"docker/volumes/#persistencia-de-dados","text":"Podemos querer que os dados da nossa aplica\u00e7\u00e3o sejam persistentes, porque assim garantimos que ela esteja distribu\u00edda e dispon\u00edvel se precisarmos consult\u00e1-la. Por\u00e9m, se escrevermos os dados nos cont\u00eaineres, por padr\u00e3o eles n\u00e3o ficar\u00e3o armazenados nesta camada, criada para ser descart\u00e1vel. Existem tr\u00eas possibilidades para contornar esta situa\u00e7\u00e3o com o Docker.","title":"Persist\u00eancia de dados"},{"location":"docker/volumes/#bind-mounts","text":"Os bind mounts est\u00e3o dispon\u00edveis no Docker desde seus primeiros dias para a persist\u00eancia de dados. Os bind mounts montar\u00e3o um arquivo ou diret\u00f3rio em seu cont\u00eainer a partir de sua m\u00e1quina host, que voc\u00ea pode referenciar atrav\u00e9s de seu caminho absoluto. Para usar o bind mounts, o arquivo ou diret\u00f3rio n\u00e3o precisa j\u00e1 existir em seu host do Docker. Se n\u00e3o existir, ser\u00e1 criado sob demanda. As montagens de liga\u00e7\u00e3o dependem do sistema de arquivos da m\u00e1quina host ter uma estrutura de diret\u00f3rio espec\u00edfica dispon\u00edvel. Voc\u00ea deve criar explicitamente um caminho para o arquivo ou pasta para colocar o armazenamento. Outra informa\u00e7\u00e3o importante sobre bind mounts \u00e9 que elas d\u00e3o acesso a arquivos confidenciais. Conforme os documentos do Docker, voc\u00ea pode alterar o sistema de arquivos do host atrav\u00e9s de processos executados em um cont\u00eainer. Isso inclui criar, modificar e excluir arquivos e diret\u00f3rios do sistema, que podem ter implica\u00e7\u00f5es de seguran\u00e7a bastante graves. Pode at\u00e9 impactar processos n\u00e3o-Docker. Para come\u00e7ar a usar o bind mounts, precisamos criar uma pasta na nossa maquina, vou cria na \u00e1rea de trabalho e nome\u00e1-la de bind. Copie a localiza\u00e7\u00e3o que vamos usar. -v --mount docker run -v /home/sposigor/bind:/teste -it ubuntu bash docker run -it --mount type = bind,src = /home/sposigor/bind,dst = /teste ubuntu bash A docker recomenda usar --mount e n\u00e3o o -v Se tiver d\u00favidas, na documenta\u00e7\u00e3o do docker run tem mais informa\u00e7\u00f5es. Para realizar o teste: Fa\u00e7a o docker run, seja em -v ou --mount. No bash do cont\u00eainer, de um ls Veja a pasta teste criada e vamos entrar nela com o cd teste/ Na pasta touch teste1.txt e escreva exit para sair V\u00e1 na sua pasta que voc\u00ea criou na m\u00e1quina local e abra ela e o arquivo teste1.txt vai est\u00e1 l\u00e1. Repita o processo de 1 \u00e1 3, com um novo cont\u00eainer e o arquivo criado no cont\u00eainer anterior persiste l\u00e1.","title":"Bind Mounts"},{"location":"docker/volumes/#volumes","text":"Os volumes s\u00e3o um \u00f3timo mecanismo para adicionar uma camada de persist\u00eancia de dados em seus cont\u00eaineres do Docker, especialmente para uma situa\u00e7\u00e3o em que voc\u00ea precisa persistir dados ap\u00f3s desligar seus cont\u00eaineres. Volumes, portanto \u00e9 a solu\u00e7\u00e3o mais recomendada pelo docker para usar em ambientes de produ\u00e7\u00e3o e afins. O docker volume ls observa os volumes dispon\u00edveis: DRIVER VOLUME NAME DRIVER : \u00c9 o volume do drive VOLUME NAME : \u00c9 o nome do volume Criar um volume novo docker volume create e o nome do volume docker volume create testando Vamos colocar em produ\u00e7\u00e3o: -v --mount docker run -v testando:/teste -it ubuntu bash docker run -t -i --mount type = bind,src = testando,dst = /teste ubuntu bash Fa\u00e7a o docker run, seja em -v ou --mount. No bash do container, de um ls Veja a pasta teste que foi criada e vamos entrar nela com o cd teste/ Dentro da pasta touch teste1.txt e escreva exit para sair Repita o processo de 1 \u00e1 3, com um novo container e o arquivo criado no container anterios persiste l\u00e1. Deve ter surgido uma duvida, aonde est\u00e1 esse arquivo que criei? Para isso vamos para o terminal: No terminal sudo su cd /var/lib/docker/volumes ls para verificar os arquivos O volume criado vai est\u00e1 aqui, cd testando ls vai ter uma pasta _data cd _data e em seguida ls Encontrou o arquivo que foi criado Os volumes do Docker s\u00e3o completamente manipulados pelo pr\u00f3prio Docker e, portanto, independentes da estrutura de diret\u00f3rios e do sistema operacional da m\u00e1quina host. Quando voc\u00ea usa um volume, um novo diret\u00f3rio \u00e9 criado no diret\u00f3rio de armazenamento do Docker na m\u00e1quina host e o Docker gerencia o conte\u00fado desse diret\u00f3rio. Por ultimo podemos passar diretamente do docker run o volume que ele se encarrega de criar -v --mount docker run -v volume_novo:/teste -it ubuntu bash docker run -t -i --mount type = bind,src = volume_novo,dst = /teste ubuntu bash docker volume ls e a sa\u00edda: DRIVER VOLUME NAME local testando local volume_novo","title":"Volumes"},{"location":"docker/volumes/#tmpfs-mounts","text":"O tmpfs mounts \u00e9 para espa\u00e7os de armazenamento pequenos e ef\u00eameros que s\u00f3 podem ser usados \u200b\u200bpor um \u00fanico cont\u00eainer, existe o sistema de arquivos tmpfs. Ele \u00e9 apoiado apenas pelo armazenamento RAM no sistema host. Essa funcionalidade s\u00f3 est\u00e1 dispon\u00edvel se voc\u00ea estiver executando o Docker no Linux. Seguindo a ordem para criar um tmpfs \u00e9 mais simples, j\u00e1 possui a pr\u00f3pria flag --tmpfs: docker run -it --tmpfs = /app ubuntu bash Perceba que a pasta app que criamos usando o --tmpfs, est\u00e1 com um fundo verde, assim como o tmp, ent\u00e3o significa que ela \u00e9 tempor\u00e1ria, quando o cont\u00eainer for finalizado, os dados ali s\u00e3o apagados. Ent\u00e3o qual \u00e9 a utilidade de usar o tmpfs? \u00c9 que ela armazena os arquivos na mem\u00f3ria do host e n\u00e3o na camada de escrita do cont\u00eaineres r/w, ou seja, se existem dados sens\u00edveis para serem armazenados no processo e por quest\u00f5es de segura n\u00e3o deseja escrever na camada de escrita do cont\u00eainer r/w, o tmpfs \u00e9 recomendando nessa situa\u00e7\u00e3o. Para mais uma aplica\u00e7\u00e3o podemos usar como par\u00e2metro do --mount: docker run -it --mount type = tmpfs,dst = /teste ubuntu bash","title":"tmpfs mounts"},{"location":"docker%20swarm/o%20que%20%C3%A9%20swarm/","text":"O que \u00e9 o Swarm? \u00b6 Imagine uma orquestra, com todas aquelas pessoas tocando instrumentos e com um maestro que transforma, direcionar e guia o ritmo da m\u00fasica. Exemplo de Orquestra E em seguida transformamos isso em c\u00f3digo e estrutura, chegamos nesse modelo: Pessoas que tocam a orquestra : S\u00e3o os computadores, para cada pessoa, imagine um computador Instrumentos : Para cada instrumento, imagine que seja um docker/trabalhador Maestro : Esse \u00e9 o cara, no docker, chamamos ele de Swarm/gerente, \u00e9 o respons\u00e1vel por dividir, gerenciar e garantir a estabilidade e tudo isso sem precisar que algu\u00e9m fique de olho. Musica : Por ultimo a musica, qual nota tocar? quando tocar? atento a cada nota, se houver um erro \u00e9 resolvido por ele e essa vamos chamar conta ineres, que v\u00e3o ser controlados pelo gerente. Ilustra\u00e7\u00e3o simples: Um pouco de teoria \u00b6 As caracter\u00edsticas de gerenciamento de agrupamento e orquestra\u00e7\u00e3o incorporadas no Docker Engine s\u00e3o constru\u00eddas utilizando o swarmkit. O Swarmkit \u00e9 um projeto separado que implementa a camada de orquestra\u00e7\u00e3o do Docker sendo utilizado diretamente dentro do Docker. Um swarm consiste em m\u00faltiplos hospedeiros Docker que funcionam em modo swarm e agem como gerentes (para gerir membros e delega\u00e7\u00e3o) e trabalhadores (que gerem servi\u00e7os de swarm). Um determinado anfitri\u00e3o Docker pode ser um gerente, um trabalhador, ou desempenhar ambas as fun\u00e7\u00f5es. Quando se cria um servi\u00e7o, define-se o seu estado ideal (n\u00famero de r\u00e9plicas, rede e recursos de armazenamento dispon\u00edveis, portas que o servi\u00e7o exp\u00f5e ao mundo exterior, e mais). O Docker trabalha para manter esse estado desejado. Por exemplo, se um n\u00f3 de trabalhador ficar indispon\u00edvel, Docker programa as tarefas desse n\u00f3 em outros n\u00f3s. Uma tarefa \u00e9 um cont\u00eainer em funcionamento que faz parte de um servi\u00e7o de swarm sendo gerido por um gerente de swarm, em oposi\u00e7\u00e3o a um cont\u00eainer independente. Uma das principais vantagens dos servi\u00e7os de swarm sobre os cont\u00eaineres independentes \u00e9 que se pode modificar a configura\u00e7\u00e3o de um servi\u00e7o, incluindo as redes e os volumes a que est\u00e1 ligado, sem necessidade de reiniciar manualmente o servi\u00e7o. O Docker ir\u00e1 atualizar a configura\u00e7\u00e3o, parar as tarefas do servi\u00e7o com a configura\u00e7\u00e3o desatualizada, e criar que correspondam \u00e0 configura\u00e7\u00e3o desejada. Quando o Docker funciona em modo de swarm, ainda \u00e9 poss\u00edvel executar cont\u00eaineres independentes em qualquer um dos anfitri\u00f5es Docker que participam no swarm, bem como servi\u00e7os de swarm. Uma diferen\u00e7a chave entre cont\u00eaineres independentes e servi\u00e7os de swarm \u00e9 que apenas os gerentes de swarm podem gerir um swarm, enquanto os cont\u00eaineres independentes podem ser iniciados em qualquer daemon. O Docker daemons da doca podem participar num swarm como gerentes, trabalhadores, ou ambos. Da mesma forma que se pode usar Docker Compose para definir e gerir cont\u00eaineres, pode-se definir e gerir pilhas de servi\u00e7os de Swarm. Continue a ler para obter detalhes sobre conceitos relacionados com os servi\u00e7os de swarm de Docker, incluindo n\u00f3s, servi\u00e7os, tarefas, e equil\u00edbrio de carga mais conhecido como Load balancing. A documenta\u00e7\u00e3o docker, vai definir o swarm/gerentes como manage e os computadores com o docker de works e os no\u015b de nodes. Nodes - n\u00f3 \u00b6 Um n\u00f3 \u00e9 um exemplo do motor Docker que participa no swarm. Tamb\u00e9m se pode pensar nisto como um n\u00f3 de Docker. Pode-se correr um ou mais n\u00f3s num \u00fanico computador f\u00edsico, ou em um servidor de nuvem, mas as implementa\u00e7\u00f5es de swarm de produ\u00e7\u00e3o incluem tipicamente n\u00f3s Docker distribu\u00eddos por m\u00faltiplas m\u00e1quinas f\u00edsicas e de nuvem. Para implantar a sua aplica\u00e7\u00e3o num swarm, submete uma defini\u00e7\u00e3o de servi\u00e7o a um n\u00f3 gerente. O n\u00f3 gerente despacha unidades de trabalho chamadas tarefas para n\u00f3s de trabalhadores. Os n\u00f3s gerentes tamb\u00e9m executam as fun\u00e7\u00f5es de orquestra\u00e7\u00e3o e gerenciamento de agrupamento necess\u00e1rias para manter o estado desejado do swarm. Os n\u00f3s gerentes elegem um \u00fanico l\u00edder para realizar tarefas de orquestra\u00e7\u00e3o. Esses n\u00f3s trabalhadores recebem e executam as tarefas enviadas pelos n\u00f3s gerentes. Por defeito, os n\u00f3s gerentes tamb\u00e9m executam servi\u00e7os como n\u00f3s trabalhadores, mas pode configur\u00e1-los para executar tarefas de gerenciamento exclusivamente e ser n\u00f3s apenas gerentes. Um agente corre em cada n\u00f3 de trabalhadores e informa sobre as tarefas que lhe s\u00e3o atribu\u00eddas. O n\u00f3 trabalhadores notifica o n\u00f3 gerente do estado atual das suas tarefas atribu\u00eddas, para que o gerente possa manter o estado desejado de cada trabalhadores. Tarefas e servi\u00e7os \u00b6 Um servi\u00e7o \u00e9 a defini\u00e7\u00e3o das tarefas a executar nos n\u00f3s do gerente ou do trabalhador. \u00c9 a estrutura central do sistema do swarm e a raiz prim\u00e1ria da intera\u00e7\u00e3o do usu\u00e1rio com o swarm. Quando se cria um servi\u00e7o, especifica-se a imagem do cont\u00eainer a utilizar e os comandos a executar dentro de cont\u00eaineres em funcionamento. No modelo de servi\u00e7os replicados, o gerente do swarm distribui um n\u00famero espec\u00edfico de tarefas replicadas entre os n\u00f3s, com base na escala que se define no estado desejado. Para servi\u00e7os globais, o swarm executa uma tarefa para o servi\u00e7o em cada n\u00f3 dispon\u00edvel no agrupamento. Uma tarefa transporta um cont\u00eainer Docker e os comandos para correr dentro do cont\u00eainer. \u00c9 a unidade de programa\u00e7\u00e3o at\u00f4mica do swarm. Os n\u00f3s gerentes atribuem tarefas aos n\u00f3s de trabalhadores conforme o n\u00famero de r\u00e9plicas definidas na escala de servi\u00e7o. Uma vez atribu\u00edda uma tarefa a um n\u00f3, este n\u00e3o pode deslocar-se para outro n\u00f3. S\u00f3 pode funcionar com o n\u00f3 atribu\u00eddo ou falhar. Load balancing \u00b6 O gerente do swarm utiliza o equil\u00edbrio da carga de entrada para expor os servi\u00e7os que pretende disponibilizar externamente ao swarm. O gerente de swarm pode atribuir automaticamente ao servi\u00e7o em uma porta ou pode configurar uma porta para o servi\u00e7o. \u00c9 poss\u00edvel especificar qualquer porta n\u00e3o utilizada. Se n\u00e3o especificar uma porta, o gerente do swarm atribui ao servi\u00e7o uma porta no intervalo 30000-32767. Componentes externos, tais como equilibradores de carga de nuvem, podem acessar o servi\u00e7o na porta de qualquer n\u00f3 do cluster, quer o n\u00f3 esteja ou n\u00e3o a executar a tarefa para o servi\u00e7o. Todos os n\u00f3s na rota de entrada do swarm de liga\u00e7\u00f5es a uma inst\u00e2ncia de tarefa em execu\u00e7\u00e3o. O modo swarm tem um componente DNS interno que atribui automaticamente a cada servi\u00e7o no swarm uma entrada DNS. O gerente do swarm utiliza o equil\u00edbrio de carga interno para distribuir pedidos entre servi\u00e7os dentro do cluster, com base no nome DNS do servi\u00e7o. Raft - Consenso Distribu\u00eddos \u00b6 Antes de continuamos a estudar sobre swarm \u00e9 importante falar sobre um algoritmo que se chama Raft, o respons\u00e1vel pelas decis\u00f5es, \u00e9 o c\u00e9rebro dessa estrutura, para isso vou deixa aqui a Raft . \u00c9 muito importante que voc\u00ea entenda um pouco sobre o Raft, j\u00e1 que essa express\u00e3o vai se repetir mais algumas vezes, em kubernetes, por exemplo. Entender o raft \u00e9 criar melhores aplica\u00e7\u00f5es que usam docker, kubernetes e outras solu\u00e7\u00f5es que usam esse c\u00e9rebro por tr\u00e1s das decis\u00f5es. Nesse ponto, encontrei dois v\u00eddeos did\u00e1ticos sobre o assunto. Linuxtips usar a explica\u00e7\u00e3o visual do Ben Johnson para explicar sobre raft E tamb\u00e9m Algoritmos de consenso em sistemas distribu\u00eddos (teoria e pr\u00e1tica) - Edward Ribeiro que vai abordar o raft e mais alguns algoritmos de consenso.","title":"O que \u00e9 Swarm?"},{"location":"docker%20swarm/o%20que%20%C3%A9%20swarm/#o-que-e-o-swarm","text":"Imagine uma orquestra, com todas aquelas pessoas tocando instrumentos e com um maestro que transforma, direcionar e guia o ritmo da m\u00fasica. Exemplo de Orquestra E em seguida transformamos isso em c\u00f3digo e estrutura, chegamos nesse modelo: Pessoas que tocam a orquestra : S\u00e3o os computadores, para cada pessoa, imagine um computador Instrumentos : Para cada instrumento, imagine que seja um docker/trabalhador Maestro : Esse \u00e9 o cara, no docker, chamamos ele de Swarm/gerente, \u00e9 o respons\u00e1vel por dividir, gerenciar e garantir a estabilidade e tudo isso sem precisar que algu\u00e9m fique de olho. Musica : Por ultimo a musica, qual nota tocar? quando tocar? atento a cada nota, se houver um erro \u00e9 resolvido por ele e essa vamos chamar conta ineres, que v\u00e3o ser controlados pelo gerente. Ilustra\u00e7\u00e3o simples:","title":"O que \u00e9 o Swarm?"},{"location":"docker%20swarm/o%20que%20%C3%A9%20swarm/#um-pouco-de-teoria","text":"As caracter\u00edsticas de gerenciamento de agrupamento e orquestra\u00e7\u00e3o incorporadas no Docker Engine s\u00e3o constru\u00eddas utilizando o swarmkit. O Swarmkit \u00e9 um projeto separado que implementa a camada de orquestra\u00e7\u00e3o do Docker sendo utilizado diretamente dentro do Docker. Um swarm consiste em m\u00faltiplos hospedeiros Docker que funcionam em modo swarm e agem como gerentes (para gerir membros e delega\u00e7\u00e3o) e trabalhadores (que gerem servi\u00e7os de swarm). Um determinado anfitri\u00e3o Docker pode ser um gerente, um trabalhador, ou desempenhar ambas as fun\u00e7\u00f5es. Quando se cria um servi\u00e7o, define-se o seu estado ideal (n\u00famero de r\u00e9plicas, rede e recursos de armazenamento dispon\u00edveis, portas que o servi\u00e7o exp\u00f5e ao mundo exterior, e mais). O Docker trabalha para manter esse estado desejado. Por exemplo, se um n\u00f3 de trabalhador ficar indispon\u00edvel, Docker programa as tarefas desse n\u00f3 em outros n\u00f3s. Uma tarefa \u00e9 um cont\u00eainer em funcionamento que faz parte de um servi\u00e7o de swarm sendo gerido por um gerente de swarm, em oposi\u00e7\u00e3o a um cont\u00eainer independente. Uma das principais vantagens dos servi\u00e7os de swarm sobre os cont\u00eaineres independentes \u00e9 que se pode modificar a configura\u00e7\u00e3o de um servi\u00e7o, incluindo as redes e os volumes a que est\u00e1 ligado, sem necessidade de reiniciar manualmente o servi\u00e7o. O Docker ir\u00e1 atualizar a configura\u00e7\u00e3o, parar as tarefas do servi\u00e7o com a configura\u00e7\u00e3o desatualizada, e criar que correspondam \u00e0 configura\u00e7\u00e3o desejada. Quando o Docker funciona em modo de swarm, ainda \u00e9 poss\u00edvel executar cont\u00eaineres independentes em qualquer um dos anfitri\u00f5es Docker que participam no swarm, bem como servi\u00e7os de swarm. Uma diferen\u00e7a chave entre cont\u00eaineres independentes e servi\u00e7os de swarm \u00e9 que apenas os gerentes de swarm podem gerir um swarm, enquanto os cont\u00eaineres independentes podem ser iniciados em qualquer daemon. O Docker daemons da doca podem participar num swarm como gerentes, trabalhadores, ou ambos. Da mesma forma que se pode usar Docker Compose para definir e gerir cont\u00eaineres, pode-se definir e gerir pilhas de servi\u00e7os de Swarm. Continue a ler para obter detalhes sobre conceitos relacionados com os servi\u00e7os de swarm de Docker, incluindo n\u00f3s, servi\u00e7os, tarefas, e equil\u00edbrio de carga mais conhecido como Load balancing. A documenta\u00e7\u00e3o docker, vai definir o swarm/gerentes como manage e os computadores com o docker de works e os no\u015b de nodes.","title":"Um pouco de teoria"},{"location":"docker%20swarm/o%20que%20%C3%A9%20swarm/#nodes-no","text":"Um n\u00f3 \u00e9 um exemplo do motor Docker que participa no swarm. Tamb\u00e9m se pode pensar nisto como um n\u00f3 de Docker. Pode-se correr um ou mais n\u00f3s num \u00fanico computador f\u00edsico, ou em um servidor de nuvem, mas as implementa\u00e7\u00f5es de swarm de produ\u00e7\u00e3o incluem tipicamente n\u00f3s Docker distribu\u00eddos por m\u00faltiplas m\u00e1quinas f\u00edsicas e de nuvem. Para implantar a sua aplica\u00e7\u00e3o num swarm, submete uma defini\u00e7\u00e3o de servi\u00e7o a um n\u00f3 gerente. O n\u00f3 gerente despacha unidades de trabalho chamadas tarefas para n\u00f3s de trabalhadores. Os n\u00f3s gerentes tamb\u00e9m executam as fun\u00e7\u00f5es de orquestra\u00e7\u00e3o e gerenciamento de agrupamento necess\u00e1rias para manter o estado desejado do swarm. Os n\u00f3s gerentes elegem um \u00fanico l\u00edder para realizar tarefas de orquestra\u00e7\u00e3o. Esses n\u00f3s trabalhadores recebem e executam as tarefas enviadas pelos n\u00f3s gerentes. Por defeito, os n\u00f3s gerentes tamb\u00e9m executam servi\u00e7os como n\u00f3s trabalhadores, mas pode configur\u00e1-los para executar tarefas de gerenciamento exclusivamente e ser n\u00f3s apenas gerentes. Um agente corre em cada n\u00f3 de trabalhadores e informa sobre as tarefas que lhe s\u00e3o atribu\u00eddas. O n\u00f3 trabalhadores notifica o n\u00f3 gerente do estado atual das suas tarefas atribu\u00eddas, para que o gerente possa manter o estado desejado de cada trabalhadores.","title":"Nodes - n\u00f3"},{"location":"docker%20swarm/o%20que%20%C3%A9%20swarm/#tarefas-e-servicos","text":"Um servi\u00e7o \u00e9 a defini\u00e7\u00e3o das tarefas a executar nos n\u00f3s do gerente ou do trabalhador. \u00c9 a estrutura central do sistema do swarm e a raiz prim\u00e1ria da intera\u00e7\u00e3o do usu\u00e1rio com o swarm. Quando se cria um servi\u00e7o, especifica-se a imagem do cont\u00eainer a utilizar e os comandos a executar dentro de cont\u00eaineres em funcionamento. No modelo de servi\u00e7os replicados, o gerente do swarm distribui um n\u00famero espec\u00edfico de tarefas replicadas entre os n\u00f3s, com base na escala que se define no estado desejado. Para servi\u00e7os globais, o swarm executa uma tarefa para o servi\u00e7o em cada n\u00f3 dispon\u00edvel no agrupamento. Uma tarefa transporta um cont\u00eainer Docker e os comandos para correr dentro do cont\u00eainer. \u00c9 a unidade de programa\u00e7\u00e3o at\u00f4mica do swarm. Os n\u00f3s gerentes atribuem tarefas aos n\u00f3s de trabalhadores conforme o n\u00famero de r\u00e9plicas definidas na escala de servi\u00e7o. Uma vez atribu\u00edda uma tarefa a um n\u00f3, este n\u00e3o pode deslocar-se para outro n\u00f3. S\u00f3 pode funcionar com o n\u00f3 atribu\u00eddo ou falhar.","title":"Tarefas e servi\u00e7os"},{"location":"docker%20swarm/o%20que%20%C3%A9%20swarm/#load-balancing","text":"O gerente do swarm utiliza o equil\u00edbrio da carga de entrada para expor os servi\u00e7os que pretende disponibilizar externamente ao swarm. O gerente de swarm pode atribuir automaticamente ao servi\u00e7o em uma porta ou pode configurar uma porta para o servi\u00e7o. \u00c9 poss\u00edvel especificar qualquer porta n\u00e3o utilizada. Se n\u00e3o especificar uma porta, o gerente do swarm atribui ao servi\u00e7o uma porta no intervalo 30000-32767. Componentes externos, tais como equilibradores de carga de nuvem, podem acessar o servi\u00e7o na porta de qualquer n\u00f3 do cluster, quer o n\u00f3 esteja ou n\u00e3o a executar a tarefa para o servi\u00e7o. Todos os n\u00f3s na rota de entrada do swarm de liga\u00e7\u00f5es a uma inst\u00e2ncia de tarefa em execu\u00e7\u00e3o. O modo swarm tem um componente DNS interno que atribui automaticamente a cada servi\u00e7o no swarm uma entrada DNS. O gerente do swarm utiliza o equil\u00edbrio de carga interno para distribuir pedidos entre servi\u00e7os dentro do cluster, com base no nome DNS do servi\u00e7o.","title":"Load balancing"},{"location":"docker%20swarm/o%20que%20%C3%A9%20swarm/#raft-consenso-distribuidos","text":"Antes de continuamos a estudar sobre swarm \u00e9 importante falar sobre um algoritmo que se chama Raft, o respons\u00e1vel pelas decis\u00f5es, \u00e9 o c\u00e9rebro dessa estrutura, para isso vou deixa aqui a Raft . \u00c9 muito importante que voc\u00ea entenda um pouco sobre o Raft, j\u00e1 que essa express\u00e3o vai se repetir mais algumas vezes, em kubernetes, por exemplo. Entender o raft \u00e9 criar melhores aplica\u00e7\u00f5es que usam docker, kubernetes e outras solu\u00e7\u00f5es que usam esse c\u00e9rebro por tr\u00e1s das decis\u00f5es. Nesse ponto, encontrei dois v\u00eddeos did\u00e1ticos sobre o assunto. Linuxtips usar a explica\u00e7\u00e3o visual do Ben Johnson para explicar sobre raft E tamb\u00e9m Algoritmos de consenso em sistemas distribu\u00eddos (teoria e pr\u00e1tica) - Edward Ribeiro que vai abordar o raft e mais alguns algoritmos de consenso.","title":"Raft - Consenso Distribu\u00eddos"}]}